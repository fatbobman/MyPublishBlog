<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"/><meta name="og:site_name" content="肘子的Swift记事本"/><link rel="canonical" href="https://www.fatbobman.com/tags/swiftui"/><meta name="twitter:url" content="https://www.fatbobman.com/tags/swiftui"/><meta name="og:url" content="https://www.fatbobman.com/tags/swiftui"/><title>肘子的Swift记事本</title><meta name="twitter:title" content="肘子的Swift记事本"/><meta name="og:title" content="肘子的Swift记事本"/><meta name="description" content="徐杨的个人博客,Core Data,Swift,Swift UI,Combine,健康笔记,iOS APP,Health Note,HealthNotes"/><meta name="twitter:description" content="徐杨的个人博客,Core Data,Swift,Swift UI,Combine,健康笔记,iOS APP,Health Note,HealthNotes"/><meta name="og:description" content="徐杨的个人博客,Core Data,Swift,Swift UI,Combine,健康笔记,iOS APP,Health Note,HealthNotes"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fatbobman"/><meta name="twitter:creator" content="@fatbobman"/><meta name="referrer" content="no-referrer"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to 肘子的Swift记事本"/><meta name="twitter:image" content="https://www.fatbobman.com/images"/><meta name="og:image" content="https://www.fatbobman.com/images"/><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script></head><body><header><div class="wrapper"><div class="logo"><a href="/"><img src="/images/title.svg"/></a></div><div><div class="headerIcons"><a class="icon headIconWeixin"><script>    var weixinHeadButton = $('.headIconWeixin');
    weixinHeadButton.hover(
    function(){
    $('.weixinHeadQcode').css('display','block');
    },
    function(){
    $('.weixinHeadQcode').css('display','none');
    })</script></a><a class="icon headIconTwitter" href="https://www.twitter.com/fatbobman" target="_blank" rel="noreferrer"></a><a class="icon headIconEmail" href="mailto:xuyang@me.com" target="_blank" rel="noreferrer"></a><a class="icon headIconGithub" href="https://github.com/fatbobman/" target="_blank" rel="noreferrer"></a><a class="icon headIconZhihu" href="https://www.zhihu.com/people/fatbobman3000" target="_blank" rel="noreferrer"></a><a class="icon headIconRss" href="/feed.rss" target="_blank" rel="noreferrer"></a></div></div><nav><ul><li><a href="/">首页</a></li><li><a href="/posts">文章</a></li><li><a href="https://www.fatbobman.com/healthnotes">健康笔记</a></li><li><a href="/about">关于</a></li><li><a class="selected" href="/tags">搜索</a></li></ul><div class="weixinHeadQcode" onclick="$('.weixinHeadQcode').css('display','none');"></div></nav></div></header><div class="container"><div class="wrapper"><div class="tag-detail-container"><div class="float-container "><div class="tag-detail-header"><span class="tag variant-5">SwiftUI</span><a class="browse-all-tag" href="/tags">查看全部标签</a></div></div></div><ul class="item-list"><li><article><h1 class="itme-list-title"><a href="/posts/swiftuiGesture">在 SwiftUI 下定制手势</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2022年01月10日</li></ul><p>不同于众多的内置控件，SwiftUI 没有采用对 UIGestureRecognizer（或 NSGestureRecognizer）进行包装的形式，而是重构了自己的手势体系。SwiftUI 手势在某种程度上降低了使用门槛，但由于缺乏提供底层数据的 API，严重制约了开发者的深度定制能力。在 SwiftUI 下，我们无法拥有类似构建全新 UIGestureRecongnizer 的能力。所谓的自定义手势，其实只是对系统预置手势的重构而已。本文将通过几个示例，演示如何使用 SwiftUI 提供的原生手段定制所需手势。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftPlaygrounds4">Swift Playgrounds 4 娱乐还是生产力</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-4"><a href="/tags/swift-playgrounds">Swift Playgrounds</a></li><li class="tag variant-2"><a href="/tags/playground">Playground</a></li><li class="tag tagdate">发布于2021年12月20日</li></ul><p>赶在 2021 年底，苹果终于发布了 Swift Playgrounds 4，作为近年来最具革命性意义的版本，Swift Playgrounds 4 提供了在 iPad 上开发可发行 app 的能力。本文将对 Swift Playground 4 的新功能做以介绍，并探讨将其作为开发工具的可行性。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/nsubiquitousKeyvalueStore">在 SwiftUI 下使用 NSUbiquitousKeyValueStore 同步数据</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag variant-0"><a href="/tags/cloudkit">CloudKit</a></li><li class="tag tagdate">发布于2021年12月13日</li></ul><p>NSUbiquitousKeyValueStore 是苹果官方提供的用于在设备间共享键值数据的解决方案。本文将对其用法做以简单介绍，着重探讨如何便捷地在 SwiftUI 中使用 NSUbiquitousKeyValueStore。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftUILifeCycle">SwiftUI 视图的生命周期研究</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2021年11月28日</li></ul><p>本文将作者对 SwiftUI 视图、SwiftUI 视图生命周期的理解和研究做以介绍，供大家一起探讨。在 UIKit（AppKit）的世界中，通过框架提供的大量钩子（例如 viewDidLoad、viewWillLayoutSubviews 等），开发者可以将自己的意志注入视图控制器生命周期的各个节点之中，宛如神明。在 SwiftUI 中，系统收回了上述的权利，开发者基本丧失了对视图生命周期的掌控。不少 SwiftUI 开发者都碰到过视图生命周期的行为超出预期的状况（例如视图多次构造、onAppear 无从控制等）。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/safeArea">掌握 SwiftUI 的 Safe Area</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年11月22日</li></ul><p>Safe Area（安全区域）是指不与导航栏、标签栏、工具栏或其他视图控制器提供的视图重叠的内容空间。本文将探讨如何在 SwiftUI 中获取 SafeAreaInsets、将视图绘制到安全区域之外、修改视图的安全区域等内容。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/onChange">了解 SwiftUI 的 onChange</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年10月29日</li></ul><p>从 iOS 14 开始，SwiftUI 为视图提供了 onChange 修饰器，通过使用 onChange，我们可以在视图中对特定的值进行观察，并在其更改时触发操作。本文将对 onChange 的特点、用法、注意事项以及替代方案做以介绍。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/textfield-event-focus-keyboard">SwiftUI TextField 进阶 —— 事件、焦点、键盘</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年10月21日</li></ul><p>本文将探讨涉及 SwiftUI TextField 的事件、焦点切换、键盘设置等相关的经验、技巧和注意事项。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/textfield-1">SwiftUI TextField 进阶——格式与校验</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年10月12日</li></ul><p>SwiftUI 的 TextField 可能是开发者在应用程序中最常使用的文本录入组件了。作为 UITextField（NSTextField）的 SwiftUI 封装，苹果为开发者提供了众多的构造方法和修饰符以提高其使用的便利性、定制性。但 SwiftUI 在封装中也屏蔽了不少的高级接口和功能，增加了开发者实现某些特定需要的复杂性。本文为【SwiftUI 进阶】系列文章中的一篇，在本文中，我将介绍如何在 TextField 中实现如下功能：屏蔽无效字符、判断录入的内容是否满足特定条件、对录入的文本实时格式化显示。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/attributedString">AttributedString——不仅仅让文字更漂亮</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/foundation">Foundation</a></li><li class="tag tagdate">发布于2021年10月08日</li></ul><p>在 WWDC 2021 上，苹果为开发者带来了有一个期待已久的功能——AttributedString，这意味着 Swift 开发人员不再需要使用基于 Objective-C 的 NSAttributedString 来创建样式化文本。本文将对其做全面的介绍并演示如何创建自定义属性。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/spotlight">在 Spotlight 中展示应用中的 Core Data 数据</a></h1><ul class="tag-list"><li class="tag variant-1"><a href="/tags/core-data">Core Data</a></li><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-4"><a href="/tags/spotlight">Spotlight</a></li><li class="tag tagdate">发布于2021年09月22日</li></ul><p>本文将讲解如何通过 NSCoreDataSpotlightDelegate（WWDC 2021 版本）实现将应用程序中的 Core Data 数据添加到 Spotlight 索引，方便用户查找并提高 App 的曝光率。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/sheetKit">SheetKit——SwiftUI 模态视图扩展库</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年09月16日</li></ul><p>SheetKit 是一个 SwiftUI 模态视图的扩展库。提供了数个用于模态视图的便捷展示、取消方法，以及几个用于模态视图的 View Extension</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/newInteractiveDismissDiabled">如何在 SwiftUI 中实现 interactiveDismissDisabled</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年09月15日</li></ul><p>本文中我们将探讨如何实现一个 SwiftUI 3.0 中新增功能——interactiveDismissDisabled 的增强版；如何创建更 SwiftUI 化的功能扩展。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/async-await-store">用 Async-Await 重建 SwiftUI 的 Redux-like 状态容器</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2021年09月06日</li></ul><p>本文介绍了如何使用 Swift 5.5 版本的 Async/Await 功能重构 SwiftUI 的状态容器代码。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/NavigationViewKit">用 NavigationViewKit 增强 SwiftUI 的导航视图</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2021年08月30日</li></ul><p>由于 SwiftUI 原生提供的导航手段能力有限，因此在之前的版本中，NavigationView 总是使用的不是那么的顺手。本文介绍一个我写的针对 NavigationView 的扩展库——NavigationViewKit。为原生 NavigationView 解决几个当前的痛点问题。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/coreDataInPreview">如何在 Xcode 下预览含有 Core Data 元素的 SwiftUI 视图</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/core-data">Core Data</a></li><li class="tag tagdate">发布于2021年08月28日</li></ul><p>本文将探讨导致 SwiftUI 预览崩溃的部分原因，如何在之后的开发中避免类似的崩溃出现以及如何在 Xcode 中安全可靠地预览含有 Core Data 元素的 SwiftUI 视图</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/uikitInSwiftUI">在 SwiftUI 中使用 UIKit 视图</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-6"><a href="/tags/uikit">UIKit</a></li><li class="tag tagdate">发布于2021年08月23日</li></ul><p>本文将通过对 UITextField 的包装来讲解如何在 SwiftUI 中使用 UIKit 视图、如何让你的 UIKit 包装视图具有 SwiftUI 风格、在 SwiftUI 使用 UIKit 视图需要注意的地方</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/appstorage">@AppStorage 研究</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2021年07月31日</li></ul><p>本文探讨的是如何优雅、高效、安全地在 SwiftUI 中使用@AppStorage，在不借助第三方库的情况下，解决当前@AppStorage 使用中出现的痛点</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui-ipad">在 SwiftUI 下对 iPad 进行适配</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年10月29日</li></ul><p>SwiftUI 创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记 2.0 开发初始，适配 iPad 便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配 iPad 的一些教训和心得。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/coredata-in-swiftui">聊一下在 SwiftUI 中使用 CoreData</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/core-data">Core Data</a></li><li class="tag tagdate">发布于2020年10月28日</li></ul><p>本文并非一个教你如何在 SwiftUI 下使用 CoreData 的教程。主要探讨的是在我近一年的 SwiftUI 开发中使用 CoreData 的教训、经验、心得。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthnote2-3rd-package">介绍几个我在开发健康笔记 2 用到的 Swift 或 SwiftUI 第三方库</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年10月27日</li></ul><p>本文介绍了其中几个在健康笔记开发过程中使用的第三方的开源库</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthNote2-development-memo-6">健康笔记 2.0 开发随笔（六）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年10月26日</li></ul><p>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同 iOS14 中的各种 Bug 和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊 iOS14、Xcode12 以及 SwiftUI2.0 的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthNote2-development-memo-5">健康笔记 2.0 开发随笔（五）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年10月07日</li></ul><p>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同 iOS14 中的各种 Bug 和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊 iOS14、Xcode12 以及 SwiftUI2.0 的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui-dismiss-sheet">在 SwiftUI 中制作可以控制取消手势的 Sheet</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年09月17日</li></ul><p>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理 app 各个层级 View 的弹出 Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在 Sheet 中制作一个可以实时响应的表单，并且 sheet 会感觉表单的情况响应取消手势。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthNote2-development-memo-4">健康笔记 2.0 开发随笔（四）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年09月17日</li></ul><p>本周没有太多的精力和情绪用来写代码。这两天在原来统一 sheet 管理和实时 Form 的基础上，完成了可以控制取消手势的 Sheet。这个是 SwiftUI 中一直以来的一个重要的缺失功能。 在 SwiftUI 中制作可以控制取消手势的 Sheet</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthNote2-development-memo-3">健康笔记 2.0 开发随笔（三）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年09月05日</li></ul><p>本周的由于其他琐事的原因，每天能够用于开发的时间基本上只能保证 2-3 个小时，所以进展不大。不过好在我也没有明确的进度指标。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui-input-form">如何在 SwiftUI 中创建一个实时响应的 Form</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年09月04日</li></ul><p>我的 app 健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的 Form 十分重要。本文尝试提出一个 SwiftUI 下的 Form 开发思路。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui-multiSheet">在 SwiftUI 中，根据需求弹出不同的 Sheet</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年09月04日</li></ul><p>Sheet 是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在 iOS14 上，SwiftUI 增加了 fullCover，支持了全屏的 Sheet 方式，让开发者又了更多的选择。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthNote2-development-memo-2">健康笔记 2.0 开发随笔（二）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年08月24日</li></ul><p>本周的由于其他琐事的原因，每天能够用于开发的时间基本上只能保证 2-3 个小时，所以进展不大。不过好在我也没有明确的进度指标。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui-list-foreach">聊一下 SwiftUI 中的 List 和 ForEach</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年08月24日</li></ul><p>在 SwiftUI 中使用 List 可以非常方便快速的制作各种列表。List 其实就是对 UITableView 进行的封装。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/healthNote2-development-memo-1">健康笔记 2.0 开发随笔（一）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-7"><a href="/tags/健康笔记">健康笔记</a></li><li class="tag tagdate">发布于2020年08月17日</li></ul><p>健康笔记从 2020 年 1 月上线以来，至今已经过了大半年的时间（可以从 [老人新兵 —— 一款 iOS app 的开发手记](https://zhuanlan.zhihu.com/p/103822455) 了解健康笔记 app 的由来）。在这段时间里，我对于 Swift、SwiftUI、CoreData 等都有了进一步的了解和认识。在开发 1.0 版本时所面对的问题和疑惑多数都得到了解决。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swifui-overlay">SwiftUIOverlayContainer ——可以实现各种自定义样式弹出视图的 SwitUI 库</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-3"><a href="/tags/project">Project</a></li><li class="tag tagdate">发布于2020年08月12日</li></ul><p>SwiftUI 目前可以提供 sheet,fullScreenCover,alert,actionsheet 等弹出视图用于丰富 UI 交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的 SwiftUI 库 —— SwiftUIOverlayContainer。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swipeCell">用 SwiftUI 实现 iOS mail 程序的侧滑菜单</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-3"><a href="/tags/project">Project</a></li><li class="tag tagdate">发布于2020年08月12日</li></ul><p>随着 SwiftUI2.0 的不断完善，我觉得是时候将我的 app 做一个较大的升级了。之前一直想在 app 中实现类似 iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于 UIKit 的，基本上没有能够很好的适配 SwiftUI 的项目库。最终自己在 Xcode12 实现了一个。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-import-export">HowTo —— SwiftUI2.0 文件导入导出</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月28日</li></ul><p>SwiftUI2.0 中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-scrollviewReader">HowTo —— SwiftUI2.0 使用 ScrollViewReader 定位滚动位置</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月23日</li></ul><p>SwiftUI2.0 增加了滚动定位功能，已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案，并不是通过设置具体的 offset 来进行定位，而是使用 id 来进行位置标记。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-progressView">HowTo —— SwiftUI2.0 使用 ProgressView 显示进度条</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月12日</li></ul><p>SwiftUI2.0 新增了一些便捷的内置控件，比如说 Label、ProgressView 等。其基本形态都很普通，不过都支持自定义 style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展 style 来完成。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-onOpenUrl">HowTo —— 使用 onOpenURL 处理 Universal Links</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月11日</li></ul><p>SwiftUI2.0 由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织 app, 因此提供了 onOpenURL 来处理 Univeresal Links。不同于在 AppDelegate 或 SceneDelegate 中的解决方案，onOpenURL 作为一个 view modifier，你可以在任意 View 上注册你的 app 的 URL 处理机制。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-toolbar">HowTo —— SwiftUI2.0 使用 ToolBar 替代 navigationbarItems</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月10日</li></ul><p>SwiftUI2.0 为了实现更好的多平台支持同时需要兼顾 1.0 版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如 ToolBar, navigationTitle 等。Toolbar 可以实现 navigationbarItems 的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-link-openurl">HowTo —— SwiftUI2.0 使用 Link 或 openURL 打开 URL scheme</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月10日</li></ul><p>SwiftUI2.0 提供了原生的打开 URL scheme 的功能，我们可以十分方便的在代码中调用其他的 app。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-grid">HowTO —— SwiftUI2.0 原生的 Grid</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月10日</li></ul><p>SwiftUI 的第一版中，官方并没有提供 UICollectionView 的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0 中，苹果通过 LazyVGrid、LazyHGrid 提供了 Grid 控件。该控件的实现很有 SwiftUI 的风格，和众多的第三方库有显著的区别。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-lazyStack">HowTo —— SwiftU2.0 LazyVStack LazyHStack</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月09日</li></ul><p>SwiftUI2.0 提供了 LazyVStack 和 LazyHStack，其作用是只有当 View 在可见区域内才进行渲染，这样可以大大大提高 app 执行效率</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-label">HowTo —— SwiftUI2.0 如何使用 Label</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月09日</li></ul><p>SwiftUI2.0 中新增了 Label 控件，方便我们添加由图片和文字组成的标签。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/howto-swiftui-map">HowTo—— Swift2.0 在视图中显示地图</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-1"><a href="/tags/howto">HowTo</a></li><li class="tag tagdate">发布于2020年07月09日</li></ul><p>Swift2.0 中，苹果添加了 Map，让开发者可以非常容易的在 View 中添加需要的地图元素。本文简单介绍了其用法</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui2-new-feature-2">SwiftUI2.0 —— App、Scene、新的代码结构（二）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2020年07月08日</li></ul><p>在上篇文章中我们简单了解了 App、Scene，以及几个内置 Scene 的应用。在本文中，我们着重探讨在 SwiftUI2.0 新的代码结构下如果更高效的组织 Data Flow。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftui2-new-feature-1">SwiftUI2.0 —— App、Scene、新的代码结构（一）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2020年07月08日</li></ul><p>本文简单介绍了 SwiftUI2.0 中全新提供的 App 协议、Scene 协议，浅谈了在全新的代码结构下如何组织 Data Flow，并提供了 SwiftUI2.0 中预置的 Scene 的一些使用示例。当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta 版 (20A4299v)。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/focusedBinding">@FocusedBinding 浅谈</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年07月05日</li></ul><p>在苹果 WWDC20 中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding 的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding 在目前 Xcode Version 12.0 beta 2 (12A6163b) 的版本上运行还有很多问题，但我基本上对其有了一定的了解。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftUI2-commands">SwiftUI2.0 —— Commands（macOS 菜单）</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag tagdate">发布于2020年06月27日</li></ul><p>本文介绍了 SwiftUI 2.0 中，如何为 macOS 平台添加菜单。苹果在 SwiftUI2.0 中增加了 Multiplatform 项目模板，使得同一套代码，仅需少量的适配便可以同时满足 iOS 以及 macOS 的需要。对于 macOS 上运行的 app, 拥有自定义的菜单是一个十分重要的平台特征。对于没有 macOS 开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/stateobject">SwiftUI 2.0 —— @StateObject 研究</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2020年06月26日</li></ul><p>WWDC20 刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下 SwiftUI 新提供的属性包装器@StateObject。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/observableObject-study">ObservableObject 研究——想说爱你不容易</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2020年05月17日</li></ul><p>本文主要研究在 SwiftUI 中，采用单一数据源 (Single Source of Truth) 的开发模式，ObservableObject 是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用 ObservableObject 的方式。</p></article></li><li><article><h1 class="itme-list-title"><a href="/posts/swiftUI-state">@state 研究</a></h1><ul class="tag-list"><li class="tag variant-5"><a href="/tags/swiftui">SwiftUI</a></li><li class="tag variant-0"><a href="/tags/architecture">Architecture</a></li><li class="tag tagdate">发布于2020年05月17日</li></ul><p>本文试图探讨并分析 SwiftUI 中 @State 的实现方式和运行特征；最后提供了一个有关扩展@State 功能的思路及例程。读者需要对 SwiftUI 的响应式编程有基本概念。</p></article></li></ul></div><script>    $(window).resize(function(){
        setHeight();
    })</script><script>var setHeight = function(){
    var totalHeight = $('.item-list').get(0).offsetHeight + $('footer').get(0).offsetHeight + $('header').get(0).offsetHeight + 50
    if (totalHeight < window.innerHeight) {
        $('.wrapper').height( window.innerHeight - 50 - $('footer').get(0).offsetHeight - $('header').get(0).offsetHeight );
    }
    else {
        $('.wrapper').height( $('.item-list').height );
    }
 }</script><script>$(document).ready(function(){
    setHeight();
})</script></div><footer><p>Copyright &copy; 徐杨 2022 <a href="http://beian.miit.gov.cn">辽ICP备20006550</a></p><p>Generated using <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a></p><ul class="icon"><li><a href="https://twitter.com/fatbobman" target="_blank"><img class="twitter" src="/images/twitter.svg"/></a></li><li><a href="https://github.com/fatbobman/" target="_blank"><img src="/images/github.svg"/></a></li><li><a href="https://www.zhihu.com/people/fatbobman3000" target="_blank"><img src="/images/zhihu.svg"/></a></li><li><a href="/feed.rss"><img src="/images/rss.svg"/></a></li></ul><script>
    // dynamic User by Hux
    var _gaId = 'UA-165296388-1';
    var _gaDomain = 'fatbobman.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>

<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '14e5d60a3ea6276655f9d14c58b1fcd0';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script></footer></body></html>