<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>肘子的Swift记事本</title><description>徐杨的个人博客,Core Data,Swift,Swift UI,Combine,健康笔记,iOS APP,Health Note,HealthNotes</description><link>https://www.fatbobman.com</link><language>zh</language><lastBuildDate>Thu, 21 Oct 2021 15:26:40 +0800</lastBuildDate><pubDate>Thu, 21 Oct 2021 15:26:40 +0800</pubDate><ttl>250</ttl><atom:link href="https://www.fatbobman.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.fatbobman.com/posts/textfield-event-focus-keyboard</guid><title>SwiftUI TextField 进阶 —— 事件、焦点、键盘</title><description>本文将探讨涉及 SwiftUI TextField 的事件、焦点切换、键盘设置等相关的经验、技巧和注意事项。</description><link>https://www.fatbobman.com/posts/textfield-event-focus-keyboard</link><pubDate>Thu, 21 Oct 2021 09:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本文将探讨涉及 SwiftUI TextField 的事件、焦点切换、键盘设置等相关的经验、技巧和注意事项。</p><h2>事件</h2><h3>onEditingChanged</h3><p>当 TextField 获得焦点时（进入可编辑状态），<code>onEditingChanged</code>将调用给定的方法并传递<code>true</code>值；当 TextField 失去焦点时，再次调用方法并传递<code>false</code>。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OnEditingChangedDemo</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">List</span>{
            <span class="hljs-type">TextField</span>(<span class="hljs-string">"name:"</span>,text:$name,onEditingChanged: getFocus)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFocus</span><span class="hljs-params">(focused:Bool)</span></span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"get focus:\(focused ? "</span><span class="hljs-literal">true</span><span class="hljs-string">" : "</span><span class="hljs-literal">false</span><span class="hljs-string">")"</span>)
    }
}
</code></pre><p>该参<a href=https://www.fatbobman.com/posts/textfield-event-focus-keyboard>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/textfield-event-focus-keyboard>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthnotes2year</guid><title>聊聊两年来我使用【健康笔记】的体会以及近几年的身体状况</title><description>2019年中，我有了开发用于记录自己健康数据app的想法，并在同年10月完成了【健康笔记】第一个很简陋的版本。到今天，我已经使用健康笔记两年了。从记录的数据来看，手术后这几年身体的各项指标还算保持的不错，尽管并没有达到非常理想的状态，但同我个人之前的指标比较，已经改善太多，希望能够长期保持下去。</description><link>https://www.fatbobman.com/posts/healthnotes2year</link><pubDate>Mon, 18 Oct 2021 09:30:00 +0800</pubDate><content:encoded><![CDATA[<p>2019年中，我有了开发用于记录自己健康数据app的想法，并在同年10月完成了【健康笔记】第一个很简陋的版本。到今天，我已经使用<a href="https://www.fatbobman.com/healthnotes/">健康笔记</a>两年了。</p><p>从记录的数据来看，手术后这几年身体的各项指标还算保持的不错，尽管并没有达到非常理想的状态，但同我个人之前的指标比较，已经改善太多，希望能够长期保持下去。</p><p>身体指标数据在积累到一定的量后可以反映出很多的问题和细节，不少情况下身体的主观感受同检查的结构是有不小偏差的。</p><blockquote><p>很多时候尽管自我感觉相当不错，指标提醒我需要休息并作适度调整。结合主观和客观的信息综合判断，有利于更好的了解自己的身体状态。</p></blockquote><p>另外，通过分析不同指标之间的趋势差异，也给了医生和我调整药物、调整运动量等多方面的依据。</p><img src="https://cdn.fatbobman.com/image-20211018074602941.png" alt="image-20211018074602941"/><p>肌酐从发病时的2100，透析期间长期维持的1100，在手术后3年终于降到标准值（接近标准值上限）。尽管移植手术后第4天因为突发状况进行了二次手术，好在有惊无险。虽然尽管有点小反复，不过总体的趋势还是向好的。尿素氮的趋势基本维持同肌酐一致，但始终没有降到标准范围内。</p><p>在术后三年时间中，<a href=https://www.fatbobman.com/posts/healthnotes2year>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthnotes2year>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/textfield-1</guid><title>SwiftUI TextField 进阶——格式与校验</title><description>SwiftUI 的 TextField 可能是开发者在应用程序中最常使用的文本录入组件了。作为 UITextField（NSTextField）的 SwiftUI 封装，苹果为开发者提供了众多的构造方法和修饰符以提高其使用的便利性、定制性。但 SwiftUI 在封装中也屏蔽了不少的高级接口和功能，增加了开发者实现某些特定需要的复杂性。本文为【SwiftUI 进阶】系列文章中的一篇，在本文中，我将介绍如何在 TextField 中实现如下功能：屏蔽无效字符、判断录入的内容是否满足特定条件、对录入的文本实时格式化显示。</description><link>https://www.fatbobman.com/posts/textfield-1</link><pubDate>Tue, 12 Oct 2021 13:30:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI 的 TextField 可能是开发者在应用程序中最常使用的文本录入组件了。作为 UITextField（NSTextField）的 SwiftUI 封装，苹果为开发者提供了众多的构造方法和修饰符以提高其使用的便利性、定制性。但 SwiftUI 在封装中也屏蔽了不少的高级接口和功能，增加了开发者实现某些特定需要的复杂性。本文为【SwiftUI 进阶】系列文章中的一篇，在本文中，我将介绍如何在 TextField 中实现如下功能：</p><ul><li>屏蔽无效字符</li><li>判断录入的内容是否满足特定条件</li><li>对录入的文本实时格式化显示</li></ul><blockquote><p>本文的目的并非提供一个通用的解决方案，而是通过探讨几种思路，让读者可以在面对类似需求时有迹可循。</p></blockquote><h2>为什么不自己封装新的实现</h2><p>对于很多从 UIKit 转到 SwiftUI 的开发者，当遇到 SwiftUI 官方 API 功能无法满足某些需求的情况下，非常自然地会想通过 UIViewRepresentable 来封装自己的实现（参阅 <a href="https://www.fatbobman.com/posts/uikitInSwiftUI/">在 SwiftUI 中使用 UIKit 视图</a> 了解更多内容<a href=https://www.fatbobman.com/posts/textfield-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/textfield-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/attributedString</guid><title>AttributedString——不仅仅让文字更漂亮</title><description>在 WWDC 2021 上，苹果为开发者带来了有一个期待已久的功能——AttributedString，这意味着 Swift 开发人员不再需要使用基于 Objective-C 的 NSAttributedString 来创建样式化文本。本文将对其做全面的介绍并演示如何创建自定义属性。</description><link>https://www.fatbobman.com/posts/attributedString</link><pubDate>Fri, 8 Oct 2021 08:20:00 +0800</pubDate><content:encoded><![CDATA[<p>在 WWDC 2021 上，苹果为开发者带来了有一个期待已久的功能——AttributedString，这意味着 Swift 开发人员不再需要使用基于 Objective-C 的 NSAttributedString 来创建样式化文本。本文将对其做全面的介绍并演示如何创建自定义属性。</p><h2>初步印象</h2><p>AttributedString 是具有单个字符或字符范围的属性的字符串。属性提供了一些特征，如用于显示的视觉风格、用于无障碍引导以及用于在数据源之间进行链接的超链接数据等。</p><p>下面的代码将生成一个包含粗体以及超链接的属性字符串。</p><pre data-language="swift"><code><span class="hljs-keyword">var</span> attributedString = <span class="hljs-type">AttributedString</span>(<span class="hljs-string">"请访问肘子的博客"</span>)
<span class="hljs-keyword">let</span> zhouzi = attributedString.range(of: <span class="hljs-string">"肘子"</span>)!  <span class="hljs-comment">// 获取肘子二字的范围（Range）</span>
attributedString[zhouzi].inlinePresentationIntent = .stronglyEmphasized<a href=https://www.fatbobman.com/posts/attributedString>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/attributedString>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/newFormatter</guid><title>WWDC 2021 新 Formatter API：新老比较及如何自定义</title><description>本文将通过介绍如何创建符合新 API 的 Formatter，让读者从另一个角度了解新 Formatter API 的设计机制；并对新旧两款 API 进行比较。</description><link>https://www.fatbobman.com/posts/newFormatter</link><pubDate>Fri, 1 Oct 2021 10:00:00 +0800</pubDate><content:encoded><![CDATA[<p>在 WWDC 2021 的 <a href="https://developer.apple.com/videos/play/wwdc2021/10109/" target="_blank">What's in Foundation</a> 专题中，苹果隆重介绍了适用于 Swift 的新 Formatter API。网上已经有不少文章对新 API 的用法进行了说明。本文将通过介绍如何创建符合新 API 的 Formatter，让读者从另一个角度了解新 Formatter API 的设计机制；并对新旧两款 API 进行比较。</p><blockquote><p>本文的演示代码可以在 <a href="https://github.com/fatbobman/CustomParseableFormatStyleDemo" target="_blank">Github</a> 上下载</p></blockquote><h2>新旧交替或风格转换</h2><h3>新 Formatter API 可以做什么</h3><p>新 Formatter 提供了一个便捷的接口，让 Swift 程序员以更熟悉方式在应用程序中呈现本地化的格式字符串。</p><h3>新 API 比旧 API 好吗</h3><p>好和坏都是相对的，对于以 Swift 开发为主或者只会 Swift 的程序员（比如我本人），新 Formatter 不仅学习和使用起来更容易，同时也更适合日益流行的声明式编程风格。不过从整体功能和效率上讲，新 Formatter 并不具备优势。</p><h3>新旧 API 比较</h3><h4>调用方便度</h4><p>如果说新 API 相较旧<a href=https://www.fatbobman.com/posts/newFormatter>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/newFormatter>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/localizationApp-1</guid><title>如何对 iOS 应用中的文本进行本地化</title><description>当我们使用一个英文 app 时，很多人第一时间会去查看是否有对应的中文版本。可见，在 app 中显示让使用者最亲切的语言文本是何等的重要。对于相当数量的 app 来说，如果能够将 UI 中显示的文本进行了本地化转换，基本上就完成了 app 的本地化工作。本文中，我们将探讨 iOS 开发中，如何实现显示文本的本地化工作。</description><link>https://www.fatbobman.com/posts/localizationApp-1</link><pubDate>Sun, 26 Sep 2021 16:40:00 +0800</pubDate><content:encoded><![CDATA[<p>当我们使用一个英文 app 时，很多人第一时间会去查看是否有对应的中文版本。可见，在 app 中显示让使用者最亲切的语言文本是何等的重要。对于相当数量的 app 来说，如果能够将 UI 中显示的文本进行了本地化转换，基本上就完成了 app 的本地化工作。本文中，我们将探讨 iOS 开发中，如何实现显示文本的本地化工作。本文的 <a href="https://github.com/fatbobman/LocalizationDemoForBlogPost" target="_blank">Demo</a> 采用 SwiftUI 编写。</p><h2>文本本地化的原理</h2><p>作为一个程序员，如果让你考虑设计一套逻辑对原始文本针对不同语言的进行本地化转换，我想大多数人都会考虑使用字典（键值对）的解决方案。苹果也是采取了同样的处理，通过创建针对不同语言的多个字典，系统可以轻松的查找出一个原始文本（键）对应的本地化文本（值）。比如：</p><pre data-language="swift"><code><span class="hljs-comment">//en </span>
<span class="hljs-string">"hello"</span> = <span class="hljs-string">"Hello"</span>;
</code></pre><pre data-language="swift"><code><span class="hljs-comment">//zh</span>
<span class="hljs-string">"hello"</span> = <span class="hljs-string">"你好"</span>;
</code></pre><p>这套方法就是本文中主要采取的针对文本的本地化手段。</p><p>系统在编译代码的时候，将<code>可以进行本地化操作的文本</code>进行了标记，当 app 运行在不同的语言环境（比如法文）时，系统会尝试尽<a href=https://www.fatbobman.com/posts/localizationApp-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/localizationApp-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/spotlight</guid><title>在 Spotlight 中展示应用中的 Core Data 数据</title><description>本文将讲解如何通过 NSCoreDataSpotlightDelegate（WWDC 2021 版本）实现将应用程序中的 Core Data 数据添加到 Spotlight 索引，方便用户查找并提高 App 的曝光率。</description><link>https://www.fatbobman.com/posts/spotlight</link><pubDate>Wed, 22 Sep 2021 15:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本文将讲解如何通过 NSCoreDataSpotlightDelegate（WWDC 2021 版本）实现将应用程序中的 Core Data 数据添加到 Spotlight 索引，方便用户查找并提高 App 的曝光率。</p><h2>基础</h2><h3>Spotlight</h3><p>自 2009 年登陆 iOS 以来，经过 10 多年的发展，Spotlight（聚焦）已经从苹果系统的官方应用搜索变成了一个包罗万象的功能入口，用户对 Spotligh 的使用率及依赖程度也在不断地提升。</p><p>在 Spotlight 中展示应用程序中的数据可以显著地提高应用的曝光率。</p><h3>Core Spotlight</h3><p>从 iOS 9 开始，苹果推出了 Core Spotlight 框架，让开发者可以将自己应用的内容添加到 Spotlight 的索引中，方便用户统一查找。</p><p>为应用中的项目建立 Spotlight 索引，需要以下步骤：</p><ul><li>创建一个 CSSearchableItemAttributeSet（属性集）对象，为你要索引的项目设置适合的元数据（属性）。</li><li>创建一个 CSS<a href=https://www.fatbobman.com/posts/spotlight>...></a></li></ul><br><br><h3><a href=https://www.fatbobman.com/posts/spotlight>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/sheetKit</guid><title>SheetKit——SwiftUI 模态视图扩展库</title><description>SheetKit 是一个 SwiftUI 模态视图的扩展库。提供了数个用于模态视图的便捷展示、取消方法，以及几个用于模态视图的 View Extension</description><link>https://www.fatbobman.com/posts/sheetKit</link><pubDate>Thu, 16 Sep 2021 19:50:00 +0800</pubDate><content:encoded><![CDATA[<h2>SheetKit 是什么</h2><p><a href="https://github.com/fatbobman/SheetKit" target="_blank">SheetKit</a> 是一个 SwiftUI 模态视图的扩展库。提供了数个用于模态视图的便捷展示、取消方法，以及几个用于模态视图的 View Extension。</p><p>开发 SheetKit 的主要原因：</p><ul><li>便于 Deep link 的调用</li></ul><p>SwiftUI 提供了<code>onOpenURL</code>方法让应用程序可以非常轻松的响应 Deep Link。但在实际使用中，情况并不如预期。主要因为 SwiftUI 中重要的视图展示模式：NavigationView、Sheet 等都没有迅捷、简便的重置能力。很难通过一两句代码将应用程序立即设置成我们想要的视图状态。</p><ul><li>模态视图的集中管理</li></ul><p>SwiftUI 通常采用<code>.sheet</code>来创建模态视图，对于简单的应用来说，这种形式非常直观，但如果应用程序的逻辑比较复杂、需要的模态视图众多，则上述方式就会让代码显得十分混乱，不易整理。因此，在此种情况下，通常我们会将所有的模态视图集中管理起来，统一调用。请参阅我之前的文章——<a href="https://www.fatbobman.com/posts/swiftui-multiSheet/">在 SwiftUI 中，根据需求弹出不同的 Shee<a href=https://www.fatbobman.com/posts/sheetKit>...></a></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/sheetKit>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/newInteractiveDismissDiabled</guid><title>如何在 SwiftUI 中实现 interactiveDismissDisabled</title><description>本文中我们将探讨如何实现一个 SwiftUI 3.0 中新增功能——interactiveDismissDisabled 的增强版；如何创建更 SwiftUI 化的功能扩展。</description><link>https://www.fatbobman.com/posts/newInteractiveDismissDiabled</link><pubDate>Wed, 15 Sep 2021 14:30:00 +0800</pubDate><content:encoded><![CDATA[<p>本文中我们将探讨如何实现一个 SwiftUI 3.0 中新增功能——interactiveDismissDisabled 的增强版；如何创建更 SwiftUI 化的功能扩展。</p><h2>需求</h2><p>由于 <a href="https://www.fatbobman.com/healthnotes/">健康笔记</a> 中数据录入都是在 Sheet 中进行的，为了防止用户在录入过程中由于误操作（使用手势取消 Sheet）丢失数据，因此，从最初的版本开始，我就一直使用各种手段加强对 Sheet 的控制。</p><p>去年 9 月，我在文章 <a href="https://www.fatbobman.com/posts/swiftui-dismiss-sheet/">【在 SwiftUI 中制作可以控制取消手势的 Sheet】</a> 中介绍了 <a href="https://www.fatbobman.com/healthnotes/">健康笔记 2.0</a> 版本的 Sheet 控制实现方法。目标为：</p><ul><li>通过代码控制是否允许手势取消 Sheet</li><li>在用户使用手势取消 Sheet 时可以获得通知，进而拥有更多的控制能力</li></ul><p>最终实现的效果如下：</p><p>当用户有未保存的数据时，通过手势取消 Sheet 将被阻止，用户需明确选择保存或丢弃数据。</p><p>最终的效果已经完全满足了我的要求，不过唯一遗憾的是，使用起来不是那么的直观（具体使用方式请查看 <a href="https://www.fatbobman.com/posts/swiftui-dismiss-sheet/">原文</a>）。</p><p>在今年推出的 SwiftUI 3.0 版本<a href=https://www.fatbobman.com/posts/newInteractiveDismissDiabled>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/newInteractiveDismissDiabled>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-6</guid><title>Core Data with CloudKit （六） —— 创建与多个 iCloud 用户共享数据的应用</title><description>本文中，我们将探讨如何使用 Core Data with CloudKit 创建使用 NSPersistentCloudKitContainer 与多个 iCloud 用户共享数据的应用。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-6</link><pubDate>Sat, 11 Sep 2021 19:20:00 +0800</pubDate><content:encoded><![CDATA[<p>本文中，我们将探讨如何使用 Core Data with CloudKit 创建与多个 iCloud 用户共享数据的应用。</p><blockquote><p>本篇是本系列的最后一篇，本文中将涉及大量之前提到的知识，阅读本文前，最好已经阅读过之前的 <a href="https://www.fatbobman.com/tags/cloudkit/">文章</a>。</p></blockquote><p>相信应该有不少的朋友都使用过 iOS 自带的共享相簿或者共享备忘录功能。这些功能的实现都是基于几年前苹果推出的 CloudKit 共享数据 API。在 WWDC 2021 中，苹果将该功能集成到 Core Data with CloudKit 之中，我们终于可以在使用少量 CloudKit API 的情况下，用 Core Data 的操作方式创建具有同样功能的应用程序了。</p><p>就像 WWDC session <a href="https://developer.apple.com/videos/play/wwdc2021/10015/" target="_blank">Build apps that share data through CloudKit and Core Data</a> 提到的那样，共享数据功能的实现远复杂于同步私有数据库以及同步公共数据库。尽管苹果提供了不少新的 API 来简化该操作，但想完整的在应用程序中实现该功能仍具有不小<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-6>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-6>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/async-await-store</guid><title>用 Async-Await 重建 SwiftUI 的 Redux-like 状态容器</title><description>本文介绍了如何使用 Swift 5.5 版本的 Async/Await 功能重构 SwiftUI 的状态容器代码。</description><link>https://www.fatbobman.com/posts/async-await-store</link><pubDate>Mon, 6 Sep 2021 11:05:00 +0800</pubDate><content:encoded><![CDATA[<p>经过两年多的时间，SwiftUI 发展到当前的 3.0 版本，无论 SwiftUI 的功能还是 Swift 语言本身在这段时间里都有了巨大的提升。是时候使用 Async/Await 来重构我的的状态容器代码了。</p><h2>SwiftUI 的状态容器</h2><p>我是从王巍的 <a href="https://objccn.io/products/" target="_blank">SwiftUI 与 Combine 编程</a> 一书中，第一次接触到<code>Single souce of truth</code>式的编程思想。整体来说，同 Redux 的逻辑基本一致：</p><ul><li>将 App 当做状态机，UI 是 App 状态（State）的具体呈现。</li><li>State（值类型）被保存在一个 Store 对象当中，为了在视图中注入方便，Store 需符合<code>ObservableObject</code>协议，且为 State 设置<code>@Published</code>属性包装，保证 State 的任何变化都将被及时响应。</li><li>View 不能直接修改 State，只能通过发送 Action 间接改变 Store 中的 State 内容</li><li>Store 中的 Reducer 负责处理收到的 Action，并按照 Acti<a href=https://www.fatbobman.com/posts/async-await-store>...></a></li></ul><br><br><h3><a href=https://www.fatbobman.com/posts/async-await-store>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/NavigationViewKit</guid><title>用 NavigationViewKit 增强 SwiftUI 的导航视图</title><description>由于 SwiftUI 原生提供的导航手段能力有限，因此在之前的版本中，NavigationView 总是使用的不是那么的顺手。本文介绍一个我写的针对 NavigationView 的扩展库——NavigationViewKit。为原生 NavigationView 解决几个当前的痛点问题。</description><link>https://www.fatbobman.com/posts/NavigationViewKit</link><pubDate>Mon, 30 Aug 2021 20:10:00 +0800</pubDate><content:encoded><![CDATA[<p>最近一直在为我的 iOS 健康管理 app<a href="https://www.fatbobman.com/healthnotes/">健康笔记 3.0</a> 做前期的准备工作。</p><p>由于 SwiftUI 原生提供的导航手段能力有限，因此在之前的版本中，NavigationView 总是使用的不是那么的顺手。有以下几个我不满意的地方：</p><ul><li>缺少直接返回根视图的便捷手段</li><li>无法通过代码（不通过<code>NavigationLink</code>）跳转到新视图</li><li>双栏模式（<code>DoubleColumnNavigationViewStyle</code>）下显示风格不统一</li><li>在 iPad 下，无法在竖屏（Portrait）模式下保持双栏状态</li></ul><p>因此，在这次开发的准备阶段，我写了一个针对 NavigationView 的扩展库——<a href="https://github.com/fatbobman/NavigationViewKit" target="_blank">NavigationViewKit</a>。该扩展遵循以下几个原则：</p><ul><li>非破坏性</li></ul><p>任何新添加的功能都不能影响当前 SwiftUI 提供的原生功能，尤其是不能影响例如<code>Toolbar</code>、<code>NavigationLink</code>在 NavigationView 中的表现</p><ul><li>尽可能便于使用</li></ul><p>仅需极少的代码便可使用新增功能</p><ul><li>SwiftUI 原生风格</li></ul><p>扩展功能的调用方法尽可能同原生 S<a href=https://www.fatbobman.com/posts/NavigationViewKit>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/NavigationViewKit>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataInPreview</guid><title>如何在 Xcode 下预览含有 Core Data 元素的 SwiftUI 视图</title><description>本文将探讨导致 SwiftUI 预览崩溃的部分原因，如何在之后的开发中避免类似的崩溃出现以及如何在 Xcode 中安全可靠地预览含有 Core Data 元素的 SwiftUI 视图</description><link>https://www.fatbobman.com/posts/coreDataInPreview</link><pubDate>Sat, 28 Aug 2021 08:20:00 +0800</pubDate><content:encoded><![CDATA[<p>从 SwiftUI 诞生之日起，预览（Canvas Preview ）一直是个让开发者又爱又恨的功能。当预览正常工作时，它可以极大地提高开发效率；而预览又随时可能因为各种莫名其妙的原因崩溃，不仅影响开发进程，同时又让开发者感到沮丧（很难排查出导致预览崩溃的故障）。</p><p>在预览含有 Core Data 元素的视图时崩溃的出现次数会愈发频繁，在某种程度上可能已经影响了开发者在 SwiftUI 中使用 Core Data 的热情。</p><p>结合两年来我在 SwiftUI 中使用 Core Data 的经验和教训，我们将在本文中探讨：</p><ul><li>导致 SwiftUI 预览崩溃的部分原因</li><li>如何在之后的开发中避免类似的崩溃出现</li><li>如何在 Xcode 中安全可靠地预览含有 Core Data 元素的 SwiftUI 视图</li></ul><h2>预览</h2><h3>预览是模拟器</h3><p>预览是模拟器，是一个高度优化且精简的模拟器。</p><p>预览在 Xcode 中的<strong>工作原理</strong>同标准的模拟器十分接近。但为了让它可以即时响应 SwiftUI 视图的变化，苹果对其做出了不少的修改。如果说标准的模拟器可以涵<a href=https://www.fatbobman.com/posts/coreDataInPreview>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataInPreview>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/uikitInSwiftUI</guid><title>在 SwiftUI 中使用 UIKit 视图</title><description>本文将通过对 UITextField 的包装来讲解如何在 SwiftUI 中使用 UIKit 视图、如何让你的 UIKit 包装视图具有 SwiftUI 风格、在 SwiftUI 使用 UIKit 视图需要注意的地方</description><link>https://www.fatbobman.com/posts/uikitInSwiftUI</link><pubDate>Mon, 23 Aug 2021 11:12:00 +0800</pubDate><content:encoded><![CDATA[<p>已迈入第三个年头的 SwiftUI 相较诞生初始已经提供了更多的原生功能，但仍有大量的事情是无法直接通过原生 SwiftUI 代码来完成的。在相当长的时间中开发者仍需在 SwiftUI 中依赖 UIKit（AppKit）代码。好在，SwiftUI 为开发者提供了便捷的方式将 UIKit（AppKit）视图（或控制器）包装成 SwiftUI 视图。</p><p>本文将通过对 UITextField 的包装来讲解以下几点：</p><ul><li>如何在 SwiftUI 中使用 UIKit 视图</li><li>如何让你的 UIKit 包装视图具有 SwiftUI 风格</li><li>在 SwiftUI 使用 UIKit 视图需要注意的地方</li></ul><blockquote><p><strong>如果你已经对如何使用<code>UIViewRepresentable</code>有所掌握，可以直接从<code>SwiftUI 风格化</code>部分阅读</strong></p></blockquote><h2>基础</h2><p>在具体演示包装代码之前，我们先介绍一些与在 SwiftUI 中使用 UIKit 视图有关的基础知识。</p><blockquote><p>无需担心是否能立即理解下述内容，在后续的演示中会有更多的内容帮助你掌握相关知识。</p></blockquote><h3>生命周期</h3><p>SwiftUI 同 UIKit<a href=https://www.fatbobman.com/posts/uikitInSwiftUI>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/uikitInSwiftUI>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/blogUpgrade</guid><title>博客更新记</title><description>上个周末，我将博客进行了一番装修升级。我对本次更新的效果比较满意，并非博客变得多好，而是通过此次更新，让我对当今的 Web 技术有了一定的了解。同时在本次更新过程中，无论是调试 Swift 代码、CSS 代码还是 Markdown 文档，都是在 Visual Studio Code 中进行的，这也让我对 Visual Studio Code 有了进一步的认识和掌握。</description><link>https://www.fatbobman.com/posts/blogUpgrade</link><pubDate>Tue, 17 Aug 2021 18:30:00 +0800</pubDate><content:encoded><![CDATA[<p>上个周末，我将本博客进行了一番装修升级。我对本次更新的效果比较满意，并非博客变得多好，而是通过此次更新，让我对当今的 Web 技术有了一定的了解。同时在本次更新过程中，无论是调试 Swift 代码、CSS 代码还是 Markdown 文档，都是在 Visual Studio Code 中进行的，这也让我对 Visual Studio Code 有了进一步的认识和掌握。</p><p>通过本文将这几天更新过程记录下来。</p><blockquote><p>作为一个使用 CSS、javascript 仅几天的人来说，本文的内容可能并不正确或相当偏颇，望见谅。</p></blockquote><h2>本次更新目标</h2><p>在完全停止写博客和写代码超过 15 年后，2020 年我重新创建了自己的个人博客。目的同之前的博客一样，记录并分享自己的编程学习心得、体会、经验和教训。</p><p>本博客的主题是记录有关 Swift 学习方面的内容，因此在使用了一段时间的 WordPress、Hexo 后，我找到了一个由 Swift 编写的静态站点生成器 <a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a>，并用它完成了博客的第一次重大调整。</p><blockquote><p>如果对 Publis<a href=https://www.fatbobman.com/posts/blogUpgrade>...></a></p></blockquote><br><br><h3><a href=https://www.fatbobman.com/posts/blogUpgrade>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-5</guid><title>Core Data with CloudKit（五）—— 同步公共数据库</title><description>本文将介绍如何通过 Core Data with CloudKit 将公共数据库同步到本地，在本地创建 Core Data 数据库镜像。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-5</link><pubDate>Fri, 13 Aug 2021 19:22:00 +0800</pubDate><content:encoded><![CDATA[<p>本文将介绍如何通过<code>Core Data with CloudKit</code>将公共数据库同步到本地，在本地创建<code>Core Data</code>数据库镜像。</p><h2>三种 CloudKit 数据库</h2><p>介绍一下<code>CloudKit</code>中的三种数据库：</p><h3>公共数据库</h3><p>公共数据库存放的是开发者希望任何人都能够访问的数据。不可以在公共数据库中添加自定义<code>Zone</code>，所有的数据都保存在默认的区域中。无论用户是否有<code>iCloud</code>账户，都可以通过应用程序或<code>CloudKit Web</code>服务访问其中的数据。公共数据库的内容在<code>CloudKit</code>仪表台是可见的。</p><p>公共数据库的数据容量计入应用程序的<code>CloudKit</code>存储配额。</p><h3>私有数据库</h3><p>这是<code>iCloud</code>用户存储个人数据的地方，用户将不希望公众看到的内容通过应用程序保存在这里。只有在登录了<code>iCloud</code>账户后，用户才可以访问其中的数据。默认情况下，只有用户本人才能访问自己的私有数据库中的内容（可将部分内容分享给其他的<code>iCloud</code>用户）。用户对数据拥有全部的操作权限（创建、查看、更改、删除）。私有数据库中的数据在<code>CloudKit</code>仪表台中是<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-5>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-5>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-4</guid><title>Core Data with CloudKit（四）—— 调试、测试、迁移及其他</title><description>本文聊一下在开发 Core Data with CloudKit 项目中常见的一些问题，让大家少走弯路、避免踩坑。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-4</link><pubDate>Wed, 11 Aug 2021 07:50:00 +0800</pubDate><content:encoded><![CDATA[<p>本文聊一下在开发<code>Core Data with CloudKit</code>项目中常见的一些问题，让大家少走弯路、避免踩坑。</p><h2>控制台日志信息</h2><p>一个支持<code>Core Data with CloudKit</code>的项目，控制台输出将常态化地成为上图状态。</p><p>每个项目面对的情况不同且信息中的废话较多，因此我仅就可能的信息种类做一下归纳。</p><h3>正常情况的信息</h3><ul><li><strong>初始化信息</strong></li></ul><p>代码启动后，通常首先出现在控制台的便是<code>NSPersistentCloudKitContainer</code>展示的初始化信息。包括：成功在指定<code>url</code>创建了容器，成功启用了<code>NSCloudKitMirroringDelegate</code>同步响应等。如果是首次运行项目，还会有成功在<code>iCloud</code>上创建了<code>Schema</code>之类的提示。</p><ul><li><strong>数据模型迁移信息</strong></li></ul><p>如果本地和服务器端的数据模型不一致，会出现迁移提醒。有时即使本地的<code>Core Data</code>模型和<code>iCloud</code>上的模型一致，也会看到类似<code>Skipping migration for 'ANSCKDATABASEMETADATA' because it already h<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-4>...></a></code></p><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-4>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-3</guid><title>Core Data with CloudKit（三）—— CloudKit 仪表台</title><description>本篇文章中，我们将一起研究 CloudKit 仪表台。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-3</link><pubDate>Mon, 9 Aug 2021 17:30:00 +0800</pubDate><content:encoded><![CDATA[<p>本篇文章中，我们将一起研究<code>CloudKit</code>仪表台。</p><h2>初识仪表台</h2><p>使用<code>CloudKit Dashboard</code>需要开发者拥有 <a href="https://developer.apple.com/programs/" target="_blank">Apple Developer Program</a> 账号，访问 <a href="https://icloud.developer.apple.com" target="_blank">https://icloud.developer.apple.com</a> 即可使用。</p><p>最近两年苹果对<code>CloudKit 仪表台</code>的布局做过较大的调整，上面的截图是 2021 年中时的样子。</p><p>仪表台主要分为三个部分：</p><ul><li>数据库（<code>CloudKit Database</code>）</li></ul><p>数据库<code>Web</code>客户端。涵盖管理<code>Schema</code>、<code>Record</code>、<code>Zone</code>、用户权限、容器环境等功能。</p><ul><li>遥测（<code>Telemetry</code>）</li></ul><p>使用直观的可视化效果，深入了解应用程序的服务器端性能以及跨数据库和推送事件的利用率。</p><ul><li>日志（<code>Logs</code>）</li></ul><p>CloudKit 服务器生成实时和历史日志，记录并显示应用程序和服务器之间的交互。</p><blockquote><p>在绝大多数使用<code>Core Data with CloudKit</code>的场景下，我们仅需要使用仪表板中极少数的功能（环境部署），但利用<code>CloudKit Dashboard</code>，我们可以更清楚的<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-3>...></a></p></blockquote><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-3>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-2</guid><title>Core Data with CloudKit（二） —— 同步本地数据库到 iCloud 私有数据库</title><description>本篇文章中，我们将探讨 Core Data with CloudKit 应用中最常见的场景——将本地数据库同步到 iCloud 私有数据库。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-2</link><pubDate>Mon, 9 Aug 2021 08:50:00 +0800</pubDate><content:encoded><![CDATA[<p>本篇文章中，我们将探讨<code>Core Data with CloudKit</code>应用中最常见的场景——将本地数据库同步到<code>iCloud</code>私有数据库。我们将从几个层面逐步展开：</p><ul><li>在新项目中直接支持<code>Core Data with CloudKit</code></li><li>创建可同步<code>Model</code>的注意事项</li><li>在现有项目<code>Core Date</code>中添加<code>Host in CloudKit</code>支持</li><li>有选择的同步数据</li></ul><blockquote><p>本文使用的开发环境为<code>Xcode 12.5</code>。关于私有数据库的概念，请参阅 <a href="https://www.fatbobman.com/posts/coreDataWithCloudKit-1/">Core Data with CloudKit （一） —— 基础</a>。如想实际操作本文内容，需要拥有 <a href="https://developer.apple.com/programs/" target="_blank">Apple Developer Program</a> 账号。</p></blockquote><h2>快速指南</h2><p>在应用程序中启用<code>Core Data with CloudKi</code>t 功能，只需要以下几步：</p><ol><li>使用<code>NSPersistentCloudKitContainer</code></li><li>在<code>项目 Target</code>的<code>Signing&amp;Capablities</code>中添加<code>CloudKit</code>支持</li><li>为项目创建或指定<code>CloudKit container</code></li><li>在<code>项目 Target</code>的<code>Signin<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-2>...></a></code></li></ol><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coreDataWithCloudKit-1</guid><title>Core Data with CloudKit （一） —— 基础</title><description>介绍如何使用 NSPersistentContainer 的文章并不少，但同其他 Core Data 的功能一样，用好并不容易。在两年多的使用中，我便碰到不少问题。借着今年打算在【健康笔记 3】中实现共享数据库功能的机会，我最近较系统地重新学习了 Core Data with CloudKit 并对其知识点进行了梳理。希望通过这个系列博文能让更多的开发者了解并使用 Core Data with Cloudkit 功能。</description><link>https://www.fatbobman.com/posts/coreDataWithCloudKit-1</link><pubDate>Thu, 5 Aug 2021 20:50:00 +0800</pubDate><content:encoded><![CDATA[<p>在 WWDC 2019 上，苹果为<code>Core Data</code>带了一项重大的更新——引入了<code>NSPersistentCloudKitContainer</code>。这意味着无需编写大量代码，使用<code>Core Data with CloudKit</code>可以让用户在他所有的苹果设备上无缝访问应用程序中的数据。</p><p><code>Core Data</code>为开发具有结构化数据的应用程序提供了强大的对象图管理功能。CloudKit 允许用户在登录其 iCloud 账户的每台设备上访问他们的数据，同时提供一个始终可用的备份服务。<code>Core Data with CloudKit</code>则结合了本地持久化+云备份和网络分发的优点。</p><p>2020 年、2021 年，苹果持续对<code>Core Data with CloudKit</code>进行了强化，在最初仅支持私有数据库同步的基础上，添加了公有数据库同步以及共享数据库同步的功能。</p><p>我将通过几篇博文介绍<code>Core Data with CloudKit</code>的用法、调试技巧、控制台设置并尝试更深入地研究其同步机制。</p><h2>Core Data with CloudKit<a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-1>...></a></h2><br><br><h3><a href=https://www.fatbobman.com/posts/coreDataWithCloudKit-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/appstorage</guid><title>@AppStorage 研究</title><description>本文探讨的是如何优雅、高效、安全地在 SwiftUI 中使用@AppStorage，在不借助第三方库的情况下，解决当前@AppStorage 使用中出现的痛点</description><link>https://www.fatbobman.com/posts/appstorage</link><pubDate>Sat, 31 Jul 2021 18:40:00 +0800</pubDate><content:encoded><![CDATA[<h2>前言</h2><p>在苹果生态的应用中，开发者或多或少都会使用到 UserDefaults。我个人习惯将可被用户自定义的配置信息（精度、单位、色彩等）保存在 UserDefaults 中。随着配置信息的增加，在 SwiftUI 视图中使用的@AppStorage 越来越多。</p><p>在 <a href="https://www.fatbobman.com/healthnotes/">【健康笔记 3】</a> 中，我计划开放更多的自定义选项给用户，简单的算下来要有 40-50 项，在配置视图中更会将所有用到的 UserDefaults 内容都注入进代码。</p><p>本文探讨的是如何优雅、高效、安全地在 SwiftUI 中使用@AppStorage，在不借助第三方库的情况下，解决当前@AppStorage 使用中出现的痛点：</p><ul><li>支持的数据类型少</li><li>声明繁琐</li><li>声明容易出现拼写错误</li><li>大量@AppStorage 无法统一注入</li></ul><h2>@AppStorage 基础指南</h2><p>@AppStorage 是 SwiftUI 框架提供的一个属性包装器，设计初衷是创建一种在视图中保存和读取 UserDefaults 变量的快捷方法。@AppStorage 在视图中的行为同@Sta<a href=https://www.fatbobman.com/posts/appstorage>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/appstorage>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/persistentHistoryTracking</guid><title>在 CoreData 中使用持久化历史跟踪</title><description>本文介绍了 CoreData 的 Persistent History Tracking 功能。详细讲解了从响应、提取、合并到清除的全过程处理方式，并提供了演示代码供读者使用。</description><link>https://www.fatbobman.com/posts/persistentHistoryTracking</link><pubDate>Tue, 27 Jul 2021 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h2>前言</h2><p>知道持久化历史跟踪功能已经有一段时间了，之前简单地浏览过文档但没有太当回事。一方面关于它的资料不多，学习起来并不容易；另一方面也没有使用它的特别动力。</p><p>在计划中的 <a href="https://www.fatbobman.com/healthnotes/">【健康笔记 3】</a> 中，我考虑为 App 添加 Widget 或者其他的 Extentsion，另外我也打算将 WWDC21 上介绍的 NSCoreDataCoreSpotlightDelegate 用到 App 的新版本中。为此就不得不认真地了解该如何使用持久化历史跟踪功能了。</p><h2>什么是持久化历史跟踪（Persistent History Tracking）</h2><blockquote><p>使用持久化历史跟踪（Persistent History Tracking）来确定自启用该项功能以来，存储（Store）中发生了哪些更改。 —— 苹果官方文档</p></blockquote><p>在 CoreData 中，如果你的数据保存形式是 Sqlite（绝大多数的开发者都采用此种方式）且启用了持久化历史跟踪功能，无论数据库中的数据有了何种变化（删除、添加、修改等），调用此数据库并注册了该通知的应用，都会收到<a href=https://www.fatbobman.com/posts/persistentHistoryTracking>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/persistentHistoryTracking>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/wwdc2021</guid><title>WWDC 2021 观后感</title><description>WWDC 2021 转眼间已经结束一周了。本次 WWDC 苹果一如既往的带来了新的操作系统以及一大堆开发工具、软件架构、网络服务等方面的升级。由于疫情的原因，这两年的 WWDC 都是采用录播形式，不过从视频内容上看，反倒比以前传达地更加精准，对观看者也更加地友善。本文仅从我个人感兴趣的几个角度进行一点介绍，并结合这段时间的学习谈谈使用感受。</description><link>https://www.fatbobman.com/posts/wwdc2021</link><pubDate>Fri, 18 Jun 2021 20:00:00 +0800</pubDate><content:encoded><![CDATA[<p>WWDC 2021 转眼间已经结束一周了。本次 WWDC 苹果一如既往的带来了新的操作系统以及一大堆开发工具、软件架构、网络服务等方面的升级。由于疫情的原因，这两年的 WWDC 都是采用录播形式，不过从视频内容上看，反倒比以前传达地更加精准，对观看者也更加地友善。本文仅从我个人感兴趣的几个角度进行一点介绍，并结合这段时间的学习谈谈使用感受。</p><h2>操作系统</h2><p>这几年苹果的系统一直保持一种渐进式的升级态势，即使是大版本号升级通常并不会给人特别大的惊喜和改变。不过也正是在这种逐步的变化中，苹果不断的将它多个系统的联系变得更加紧密，生态建设的愈发完善。网上已经有了大量关于系统新功能的文章，所以我仅从自己的使用上谈几点感受。</p><p>iOS 15 在旧设备上的效率相当不错（我在一台 iPhone7 上进行了安装）。相较于 iPhone，iPad 上对于多任务、多窗口的交互提升观感更明显。在后期软件适配跟上的情况下，iPad 应用或许会有一个新的爆发。Monterey 第一个版本的稳定度明显好于去年的 Big Sur，<a href=https://www.fatbobman.com/posts/wwdc2021>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/wwdc2021>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swift-in-linux</guid><title>在 Linux 系统上搭建 Swift 开发调试环境</title><description>本文的目标是在 Linux 上搭建一个可供生产标准的 Swift 开发调试环境。使用者将获得一个支持代码高亮、自动补全、定义跳转、断点调试、代码美化、代码静态扫描、跨操作系统平台配置的综合开发体验。</description><link>https://www.fatbobman.com/posts/swift-in-linux</link><pubDate>Mon, 15 Feb 2021 15:00:00 +0800</pubDate><content:encoded><![CDATA[<h2>Swift 与 Linux</h2><p>自 2015 年 Swift 宣布开源并支持 Linux 后，一晃已超过 5 年。在最初几年间尽管 Swift 发展迅速，但并未被 Linux 社区广泛接受。造成这种局面的原因较多，其中既有语言稳定性方面的问题，同时又有对 Linux 的支持不完善、缺乏具有吸引力的基础库和第三方库、热点项目不足等多方面原因。</p><p>最近两年，上述问题均得到显著改善。</p><ul><li>从 Swift5 开始 Swift 团队宣布 ABI 稳定了。自此，Swift 为应用程序提供了二进制兼容性，有了 ABI 稳定性作为基础，Swift 对其他平台的支持速度和力度将大大提高</li><li>2020 年 Swift 团队推出了 5.3 版本，除了“重要的质量提升和性能增强”之外，Swift5.3 的一个关键特性是正式支持 Linux 和 Window 平台。事实上，这也是 Swift 的发布流程首次为三个不同的平台分别设立了发布负责人。作为承诺将 Swift 引入 Linux 的第一份成果，Swift 团队宣布新的 Swift<a href=https://www.fatbobman.com/posts/swift-in-linux>...></a></li></ul><br><br><h3><a href=https://www.fatbobman.com/posts/swift-in-linux>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/publish-3</guid><title>用 Publish 创建博客（三）——插件开发</title><description>我们不仅可以利用 Publish 内置的接口来开发插件进行扩展，同时还可以使用 Publish 套件中其他的优秀库（Ink、Plot、Sweep、Files、ShellOut 等）来完成更多的创意。本文将通过几个实例（添加标签、增加属性、用代码生成内容、全文搜索、命令行部署）在展示不同扩展手段的同时向大家介绍 Publish 套件中其他的优秀成员。</description><link>https://www.fatbobman.com/posts/publish-3</link><pubDate>Wed, 3 Feb 2021 19:58:00 +0800</pubDate><content:encoded><![CDATA[<p>我们不仅可以利用 Publish 内置的接口来开发插件进行扩展，同时还可以使用 Publish 套件中其他的优秀库（Ink、Plot、Sweep、Files、ShellOut 等）来完成更多的创意。本文将通过几个实例（添加标签、增加属性、用代码生成内容、全文搜索、命令行部署）在展示不同扩展手段的同时向大家介绍 Publish 套件中其他的优秀成员。在阅读本文前，最好能先阅读 <a href="https://www.fatbobman.com/posts/publish-1/">用 Publish 创建博客（一）——入门</a>、<a href="https://www.fatbobman.com/posts/publish-2/">用 Publish 创建博客（二）——主题开发</a>。对 Publish 有个基本了解。本文篇幅较长，你可以选择自己感兴趣的实战内容阅读。</p><h2>基础</h2><h3>PublishingContext</h3><p>在 <a href="https://www.fatbobman.com/posts/publish-1/">用 Publish 创建博客（一）——入门</a> 中我们介绍过 Publish 有两个 Content 概念。其中<code>PublishingContext</code>作为根容器包含了你网站项目的全部信息（<code>Site</code>、<code>Section</code>、<code>Item</code>、<code>Page</code>等）。在对 Publish 进行的大多数扩展开发时，都需要和<code>Publishing<a href=https://www.fatbobman.com/posts/publish-3>...></a></code></p><br><br><h3><a href=https://www.fatbobman.com/posts/publish-3>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/publish-2</guid><title>用 Publish 创建博客（二）——主题开发</title><description>拥用强大的主题系统是一个静态网站生成器能否成功的重要原因之一。Publish 采用 Plot 作为主题的开发工具，让开发者在高效编写主题的同时享受到了 Swift 的类型安全的优势。本文将从 Plot 开始介绍，让读者最终学会如何创建 Publish 主题。</description><link>https://www.fatbobman.com/posts/publish-2</link><pubDate>Mon, 1 Feb 2021 16:20:00 +0800</pubDate><content:encoded><![CDATA[<p>拥用强大的主题系统是一个静态网站生成器能否成功的重要原因之一。<a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a> 采用 <a href="https://github.com/JohnSundell/Plot" target="_blank">Plot</a> 作为主题的开发工具，让开发者在高效编写主题的同时享受到了 Swift 的类型安全的优势。本文将从 Plot 开始介绍，让读者最终学会如何创建 Publish 主题。</p><h2>Plot</h2><h3>简介</h3><p>想要开发 Publish 的<code>Theme</code>主题，就不能不从 Plot 说起。</p><p>在 Swift 社区中，有不少优秀的项目致力于使用 Swift 生成 HTML：比如 Vapor 的 <a href="https://github.com/vapor/leaf" target="_blank">Leaf</a>，Point-Free 的 <a href="https://github.com/pointfreeco/swift-html" target="_blank">swift-html</a> 等，Plot 也是其中的一员。Plot 最初是由 <a href="https://swiftbysundell.com" target="_blank">John Sundell</a> 编写的并作为 Publish 套件的一部分，它主要的关注点是 Swift 的静态网站 HTML 生成，以及创建建站所需的其他格式文档，包括<code>RSS</code>、<code>podcast</code>、<code>Sitemap</code>。它与 Publish 紧密集成但同时也作为一个独立项目存在。</p><p>Plot 使用了一种被称作<code>Phantom Types</code>的技术，该技术将类型用作编译器的<a href=https://www.fatbobman.com/posts/publish-2>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/publish-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/publish-1</guid><title>用 Publish 创建博客（一）——入门</title><description>Publish 是一款专门为 Swift 开发者打造的静态网站生成器。它使用 Swift 构建整个网站，并支持主题、插件和其他大量的定制选项。 本文包含 Publish 的快速使用入门以及基本结构说明。</description><link>https://www.fatbobman.com/posts/publish-1</link><pubDate>Sat, 30 Jan 2021 21:00:00 +0800</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a> 是一款专门为 Swift 开发者打造的静态网站生成器。它使用 Swift 构建整个网站，并支持主题、插件和其他大量的定制选项。 &gt; 作为 Swift 开发者，通过 Publish 创建站点的开发过程和体验同开发其他程序很类似。</p><h2>开篇</h2><h3>开发者 John Sundell</h3><p>Publish 的开发者 John Sundell 这些年一直致力于发表关于 Swift 的高质量文章、播客和视频。他的作品大多都发布在其独立运营的 <a href="https://swiftbysundell.com/" target="_blank">Swift by Sundell</a> 上。他开发了 <a href="https://github.com/JohnSundell/Publish" target="_blank">Publish</a> 用以创建并管理自己的站点。</p><p>在开发 Publish 的过程中，他还开源了其他大量的基本库，比如 <a href="https://github.com/JohnSundell/Ink" target="_blank">Ink</a>（高效的 Markdown 解析器）、<a href="https://github.com/JohnSundell/Plot" target="_blank">Plot</a>（创建 HTML、XML、RSS 的 DSL）、<a href="https://github.com/JohnSundell/Sweep" target="_blank">Sweep</a>（高效的字符串扫描库）、<a href="https://github.com/JohnSundell/Codextended" target="_blank">Codextended</a>（Codable 增强）等。它们不仅一起构建了强大的 Publish，并且在各自的领域也是极为出色的开源库。</p><h3>我为什么使用 Publish</h3><p>我在一年前恢复自<a href=https://www.fatbobman.com/posts/publish-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/publish-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-ipad</guid><title>在 SwiftUI 下对 iPad 进行适配</title><description>SwiftUI 创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记 2.0 开发初始，适配 iPad 便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配 iPad 的一些教训和心得。</description><link>https://www.fatbobman.com/posts/swiftui-ipad</link><pubDate>Thu, 29 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI 创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记 2.0 开发初始，适配 iPad 便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配 iPad 的一些教训和心得。</p><h2>我是谁</h2><p>app 中的代码必须能高效、清晰的了解当前设备的状况，时刻搞清楚我是谁，我在哪，在干啥等等。因此在项目开始之初我便做了不少的准备并创建了一系列的代码。</p><p>比如，当前的运行设备：</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Device</span> </span>{
    <span class="hljs-comment">//MARK: 当前设备类型 iphone ipad mac</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Devicetype</span></span>{
        <span class="hljs-keyword">case</span> iphone,ipad,mac
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> deviceType:<span class="hljs-type">Devicetype</span>{
        #<span class="hljs-keyword">if</span> os(macOS)
        <span class="hljs-keyword">return</span> .mac
        #<span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span>  <span class="hljs-type">UIDevice</span>.current.userInterfaceIdiom<a href=https://www.fatbobman.com/posts/swiftui-ipad>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-ipad>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/coredata-in-swiftui</guid><title>聊一下在 SwiftUI 中使用 CoreData</title><description>本文并非一个教你如何在 SwiftUI 下使用 CoreData 的教程。主要探讨的是在我近一年的 SwiftUI 开发中使用 CoreData 的教训、经验、心得。</description><link>https://www.fatbobman.com/posts/coredata-in-swiftui</link><pubDate>Wed, 28 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本文并非一个教你如何在 SwiftUI 下使用 CoreData 的教程。主要探讨的是在我近一年的 SwiftUI 开发中使用 CoreData 的教训、经验、心得。</p><h2>SwiftUI lifecycle 中如何声明持久化存储和上下文</h2><p>在 XCode12 中，苹果新增了 SwiftUI lifecycle，让 App 完全的 SwiftUI 化。不过这就需要我们使用新的方法来声明持久化存储和上下文。</p><p>好像是从 beta6 开始，XCode 12 提供了基于 SwiftUI lifecycle 的 CoreData 模板</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CoreDataTestApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-comment">//持久化声明</span>
    <span class="hljs-keyword">let</span> persistenceController = <span class="hljs-type">PersistenceController</span>.shared

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">ContentView</span>()
       <a href=https://www.fatbobman.com/posts/coredata-in-swiftui>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/coredata-in-swiftui>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthnote2-3rd-package</guid><title>介绍几个我在开发健康笔记 2 用到的 Swift 或 SwiftUI 第三方库</title><description>本文介绍了其中几个在健康笔记开发过程中使用的第三方的开源库</description><link>https://www.fatbobman.com/posts/healthnote2-3rd-package</link><pubDate>Tue, 27 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h2><a href="https://github.com/SwiftUIX/SwiftUIX" target="_blank">SwiftUIX</a></h2><blockquote><p>SwiftUIX 试图弥补仍处于新生阶段的 SwiftUI 框架的空白，提供了广泛的组件，扩展和实用程序套件来补充标准库。 迄今为止，该项目是缺少的 UIKit / AppKit 功能的最完整的移植，力求使其以大多数类似于 Apple 的方式交付。 这个项目的目标是补充 SwiftUI 标准库，提供数百种扩展和视图，使开发人员可以轻松地通过 SwiftUI 的革命来构建应用程序。</p></blockquote><p>提供了非常多的苹果本应提供但没有提供的功能扩展。项目的发起者非常年轻，但 mac 的开发经验十分丰富。到目前为止一直保持的较高的更新频率和维护状态。这个库同时支持 UIKit 和 Appkit，对于需要做苹果生态全平台的用户十分友好。由于目前 SwiftUI 的 List 和 LazyVStack 的问题还很多，他自己在开发中也深受其苦，前天在交流中，他已经决定重做 CocoaList 功能，尤其提高对 Fetchrequest 的支持。</p><p>对于进行 SwiftUI 开发的朋友，它是十分值得推荐的。</p><p>目<a href=https://www.fatbobman.com/posts/healthnote2-3rd-package>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthnote2-3rd-package>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-6</guid><title>健康笔记 2.0 开发随笔（六）</title><description>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同 iOS14 中的各种 Bug 和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊 iOS14、Xcode12 以及 SwiftUI2.0 的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-6</link><pubDate>Mon, 26 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>收尾工作往往是最枯燥的。</p><p>最近这 10 几天，主要的工作都是查找 bug，改进性能，反复测试数据的稳定性，以及更加枯燥的文档准备工作。</p><p>向 app store 提交反倒异常顺利，中间只出现了一次反复。苹果要我确认是否会滥用用户的数据，在明确回复不会之后就通过了。想想去年底健康笔记 1.0 的上线反复折腾了我 10 多天。</p><p>XCode 12 中的 StoreKit 对于调试应用内的购买实在是太方便了，在开发的最后阶段，我将 app 分成了基础版和专业版。基础版其实已经能应对生活中绝大多数的需求了。通过 StoreKit 的模拟环境，我的应用内购买没有使用任何沙盒测试便一次性的开发调试成功，并且上线后也运行正常。极大的提高了效率！</p><p>在本次历时近两个月的开发过程中，基本上没走太多弯路。真正让我消耗精力的反倒是和 iOS 14 以及 SwiftUI 2.0 中的 Bug 斗智斗勇。很多奇怪的问题，在对自己代码反复的检查之后才能基本确认是系统的原因，然后还需要设法用最少的代码重现问题得以最终确认。从 WW<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-6>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-6>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthnote2-release</guid><title>健康笔记 2.0 正式版完成了！</title><description>经过了大半年的积累和准备，持续了 2 个月的开发，健康笔记 2.0 在昨天上线了。</description><link>https://www.fatbobman.com/posts/healthnote2-release</link><pubDate>Mon, 26 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>经过了大半年的积累和准备，持续了 2 个月的开发，健康笔记 2.0 在昨天上线了。</p><p>本次开发，我重写了健康笔记的全部代码，最后的结果个人还是比较满意的。</p><p>苹果在 2020 年无论从 iOS,Swift,SwiftUI 还是 Xcode 几个方面改进还是显著的，对我的帮助很大。</p><p>无论从功能、性能、UI 表现上，2.0 版都比 1.0 版有了较大提高。</p><p>在这里可以下载 <a href="https://apps.apple.com/us/app/health-notes-2/id1534513553"></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthnote2-release>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-5</guid><title>健康笔记 2.0 开发随笔（五）</title><description>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同 iOS14 中的各种 Bug 和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊 iOS14、Xcode12 以及 SwiftUI2.0 的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-5</link><pubDate>Wed, 7 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同 iOS14 中的各种 Bug 和异常斗智斗勇。</p><p>本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊 iOS14、Xcode12 以及 SwiftUI2.0 的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</p><h2>Bug 实在多</h2><p>2020 年苹果想在软件架构层面做出非常多的重要改变。big sur 要支持 arm，SwiftUI 要真正做到一套代码顺利的多平台运行，iOS14 也作出了在近几年肉眼可见的最大变化。不过可能是目标太多、太大，而时间又紧，至少到现在为止，bug 层出不穷，改不胜改。尤其是随着版本的升级，竟然出现了不少前面完全不曾出现的 bug，实在是令人心烦。</p><p>比如在 iOS14.2beta2 中，sheet 的 Delegate 无法响应，而在之前的所有版本都没有问题。在 iOS14.2beta2 中，View 的刷新时机有和之前有了细微的变化，在一些及特殊的情况下<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-5>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-5>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-4</guid><title>健康笔记 2.0 开发随笔（四）</title><description>本周没有太多的精力和情绪用来写代码。这两天在原来统一 sheet 管理和实时 Form 的基础上，完成了可以控制取消手势的 Sheet。这个是 SwiftUI 中一直以来的一个重要的缺失功能。 在 SwiftUI 中制作可以控制取消手势的 Sheet</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-4</link><pubDate>Thu, 17 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>经过 2 周的治疗，我父亲终于脱离的生命危险。疫情的原因，医院只允许一个护工在身边照顾，病人长时间无法见到家属而导致了较严重的心理问题。综合考虑，周末已接回家。回家 2 天后，整个状况有了非常好的转变。在这次的治疗中，我提供给医院的我父亲这几年来的各方面身体指标数据起到了很重要的作用。</p><p>本周没有太多的精力和情绪用来写代码。这两天在原来统一 sheet 管理和实时 Form 的基础上，完成了可以控制取消手势的 Sheet。这个是 SwiftUI 中一直以来的一个重要的缺失功能。 <a href="https://www.fatbobman.com/posts/swiftui-dismiss-sheet/">在 SwiftUI 中制作可以控制取消手势的 Sheet</a></p><p>Xcode 12 beta6 的 bug 还是不少，这两天我竟然见到了 3 次四国画面。 SwiftUI 2.0 的 List 问题也很多，甚至感觉比 1.0 更不稳定，而且效率有明显的问题。目前已将所有使用 List 的地方都暂时替换成了 LazyVStack。</p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-4>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-dismiss-sheet</guid><title>在 SwiftUI 中制作可以控制取消手势的 Sheet</title><description>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理 app 各个层级 View 的弹出 Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在 Sheet 中制作一个可以实时响应的表单，并且 sheet 会感觉表单的情况响应取消手势。</description><link>https://www.fatbobman.com/posts/swiftui-dismiss-sheet</link><pubDate>Thu, 17 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理 app 各个层级 View 的弹出 Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在 Sheet 中制作一个可以实时响应的表单，并且 sheet 会感觉表单的情况响应取消手势。</p></blockquote><p><a href="https://www.fatbobman.com/posts/swiftui-multiSheet/">在 SwiftUI 中，根据需求弹出不同的 Sheet</a></p><p><a href="https://www.fatbobman.com/posts/swiftui-input-form/">如何在 SwiftUI 中创建一个实时响应的 Form</a></p><h2>由来</h2><p>在之前 Form 的例子中，虽然我们可以根据表单是否进行了修改来对 cancel、edit 等做出不同的响应，但是我们并没有办法控制用户直接使用手势来取消 sheet，为了不让用户绕过程序的判断检查，不得已使用了 fullScreenCover 来规避手势取消。不过在实际使用中，尽管全屏 sheet 提供了更多的屏幕可用空间，但还是会给使用者带来了操作逻辑不统一的体验。</p><p>在去年，我使用的解决方案是，屏蔽 sheet 的拖动手势。</p><pre data-language="swift"><code> .highPriorityGesture(<span class="hljs-type">DragGesture</span>())
</code></pre><p><a href=https://www.fatbobman.com/posts/swiftui-dismiss-sheet>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-dismiss-sheet>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-3</guid><title>健康笔记 2.0 开发随笔（三）</title><description>本周的由于其他琐事的原因，每天能够用于开发的时间基本上只能保证 2-3 个小时，所以进展不大。不过好在我也没有明确的进度指标。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-3</link><pubDate>Sat, 5 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>由于家属突发疾病，最近每天都要出入医院，因此最近用于开发的时间很有限。</p><p>目前 app 已经完成了笔记、条目、数据的创建、编辑、显示、删除全部逻辑。如果不考虑图表、数据导入导出、交叉比对等功能，app 的基本功能已经完成了。</p><p>在本次开发中，我着重调整了表单的开发方式，目前表单无论从响应，判断等方便都比上一版有了很大的提高。</p><p>本次我将以前分散的输入源（source of truth）统一到了一起，不仅更便于代码管理，同时也方便实现了很多以前无法或实现起来非常困难的功能。</p><p>关于表单的处理，可以参看我的文章 <a href="https://www.fatbobman.com/posts/swiftui-input-form/">如何在 SwiftUI 中创建一个实时响应的 Form</a>。</p><p>另外，由于我的 app 对于 sheet 的使用量也很多，所以也对 sheet 的响应做出了统一的管理，这方面我记录在另一篇文章中 <a href="https://www.fatbobman.com/posts/swiftui-multiSheet/">在 SwiftUI 中，根据需求弹出不同的 Sheet</a>。</p><p>时间有限，随便记录一点。</p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-3>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-input-form</guid><title>如何在 SwiftUI 中创建一个实时响应的 Form</title><description>我的 app 健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的 Form 十分重要。本文尝试提出一个 SwiftUI 下的 Form 开发思路。</description><link>https://www.fatbobman.com/posts/swiftui-input-form</link><pubDate>Fri, 4 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>我的 app 健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的 Form 十分重要。本文尝试提出一个 SwiftUI 下的 Form 开发思路。</p><h2>健康笔记 1.0 的时候</h2><p>在开发健康笔记 1.0 的使用，当时由于 iOS13 尚不支持 onChange，当时主要使用类似的检查方式：</p><h2>对于简单情况</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"name"</span>,text:$name)
     .foregroundColor(name.<span class="hljs-built_in">count</span>.isEmpty ? .red : .black)
</code></pre><h2>稍复杂的情况</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> age = <span class="hljs-string">""</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"name"</span>,text:$name)
    .foregroundColor(!checkName() ? .red : .black)
<span class="hljs-type">TextField</span>(<span class="hljs-string">"age"</span>,text:$name)
     <a href=https://www.fatbobman.com/posts/swiftui-input-form>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-input-form>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-multiSheet</guid><title>在 SwiftUI 中，根据需求弹出不同的 Sheet</title><description>Sheet 是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在 iOS14 上，SwiftUI 增加了 fullCover，支持了全屏的 Sheet 方式，让开发者又了更多的选择。</description><link>https://www.fatbobman.com/posts/swiftui-multiSheet</link><pubDate>Fri, 4 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>Sheet 是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在 iOS14 上，SwiftUI 增加了 fullCover，支持了全屏的 Sheet 方式，让开发者又了更多的选择。</p><h2>基本用法</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> showView1 = <span class="hljs-literal">false</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> showView2 = <span class="hljs-literal">false</span>

<span class="hljs-type">List</span>{
    <span class="hljs-type">Button</span>(<span class="hljs-string">"View1"</span>){
      showView1.toggle()
    }
  .sheet(isPresented:$showView1){
    <span class="hljs-type">Text</span>(<span class="hljs-string">"View1"</span>)
  }
  
  <span class="hljs-type">Button</span>(<span class="hljs-string">"View2"</span>){
    showView2.toggle()
  }
  .sheet(isPresented:$showView2){
    <span class="hljs-type">Text</span>(<span class="hljs-string">"View2"</span>)
  }
}
</code></pre><p>上述代码，我们可以通过点击不同的按钮而弹出相对应的 View。</p><p>不过它有两个缺点：</p><ol><li>如果你的代码有多处需要使用不同 v<a href=https://www.fatbobman.com/posts/swiftui-multiSheet>...></a></li></ol><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-multiSheet>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-2</guid><title>健康笔记 2.0 开发随笔（二）</title><description>本周的由于其他琐事的原因，每天能够用于开发的时间基本上只能保证 2-3 个小时，所以进展不大。不过好在我也没有明确的进度指标。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-2</link><pubDate>Mon, 24 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本周的由于其他琐事的原因，每天能够用于开发的时间基本上只能保证 2-3 个小时，所以进展不大。不过好在我也没有明确的进度指标。</p><p>由于 2.0 在功能上同 1.0 的区别并不太大，所以在功能需求设计上不需要花费太多的时间。这半年来我自己也基本总结了一个自己用起来比较顺手的 MVVM 框架所以在最开始的 1 周，并不用太费力变完成了一个最简陋 ui 的原型版。</p><p>尽管叫原型版，但数据流、数据库操作等待基础代码都是要用于正式版中的。</p><p>在上周，苹果发布了 Xcode12 的 beta5, 其中提供了在 SwiftUI lifecycle 下的 CoreData 模版。所用的思路和我现在差不多。都是使用 static 来保证上下文的唯一性。另外苹果也提供了一个用于 preview 的思路，创建了一个 in-memory 的 Sqllite. 这个也和我现在的途径差距不大，我现在是直接通过生成 Sample NSManageObject 给 Preview 来实现的。反正都是可以在 preview 中比较好<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-2>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui-list-foreach</guid><title>聊一下 SwiftUI 中的 List 和 ForEach</title><description>在 SwiftUI 中使用 List 可以非常方便快速的制作各种列表。List 其实就是对 UITableView 进行的封装。</description><link>https://www.fatbobman.com/posts/swiftui-list-foreach</link><pubDate>Mon, 24 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>在 SwiftUI 中使用 List 可以非常方便快速的制作各种列表。List 其实就是对 UITableView 进行的封装（更多 List 的具体用法请参阅 <a href="https://zhuanlan.zhihu.com/p/110749923" target="_blank">List 基本用法</a>).</p><p>在 List 中添加动态内容，我们可以使用两种方式</p><h3>直接使用 List 自己提供的动态内容构造方法</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
  }
</code></pre><h3>在 List 中使用 ForEach</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
    }
  }
</code></pre><p>在碰到我最近出现的问题之前，我一直以为上述两种用法除了极个别的区别外，基本没有什么不同。</p><p>当时知道的区别：</p><h3>使用 ForEach 可以在同一 List 中，添加多个动态源，且可添加静态内容</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(items,id:\.<span class="hljs-keyword">self</span>){ item <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(item)
    }
    <span class="hljs-type">Text</span>(<span class="hljs-string">"<a href=https://www.fatbobman.com/posts/swiftui-list-foreach>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui-list-foreach>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/healthNote2-development-memo-1</guid><title>健康笔记 2.0 开发随笔（一）</title><description>健康笔记从 2020 年 1 月上线以来，至今已经过了大半年的时间（可以从 [老人新兵 —— 一款 iOS app 的开发手记](https://zhuanlan.zhihu.com/p/103822455) 了解健康笔记 app 的由来）。在这段时间里，我对于 Swift、SwiftUI、CoreData 等都有了进一步的了解和认识。在开发 1.0 版本时所面对的问题和疑惑多数都得到了解决。</description><link>https://www.fatbobman.com/posts/healthNote2-development-memo-1</link><pubDate>Mon, 17 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>健康笔记从 2020 年 1 月上线以来，至今已经过了大半年的时间（可以从 <a href="https://zhuanlan.zhihu.com/p/103822455" target="_blank">老人新兵 —— 一款 iOS app 的开发手记</a> 了解健康笔记 app 的由来）。在这段时间里，我对于 Swift、SwiftUI、CoreData 等都有了进一步的了解和认识。在开发 1.0 版本时所面对的问题和疑惑多数都得到了解决。</p></blockquote><p>最近随着 iOS14 发布的临近，同时也想将这短时间来学习的知识进行更系统的整理和应用，于是便将健康笔记 2.0 的开发工作提上了日程，并已经着手进行中。</p><h2>健康笔记 2.0 的规化</h2><ul><li>功能</li></ul><p>健康笔记 1.0 目前的功能已基本能够满足我个人的日常使用，在上线这段时间内，我也根据用户提出的建议增加了部分新功能。因此在 2.0 上，app 核心功能的增加并不是太多，主要集中在两点：</p><ul><li>数据类型</li></ul><p>1.0 中当前支持两种数据类型，一种是数字型（仅记录一个数字+日期），另一个是选项型（自定义选项内容+日期），在 2.0 中，新增了其他 5 中数据类型包括：双数字型、数字选项型、起始时间型等。使用者可以记录生<a href=https://www.fatbobman.com/posts/healthNote2-development-memo-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/healthNote2-development-memo-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swifui-overlay</guid><title>SwiftUIOverlayContainer ——可以实现各种自定义样式弹出视图的 SwitUI 库</title><description>SwiftUI 目前可以提供 sheet,fullScreenCover,alert,actionsheet 等弹出视图用于丰富 UI 交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的 SwiftUI 库 —— SwiftUIOverlayContainer。</description><link>https://www.fatbobman.com/posts/swifui-overlay</link><pubDate>Wed, 12 Aug 2020 16:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI 目前可以提供 sheet,fullScreenCover,alert,actionsheet 等弹出视图用于丰富 UI 交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的 SwiftUI 库 —— SwiftUIOverlayContainer。</p></blockquote><p>SwiftUIOverlayContainer 本身并不提供任何预置的视图样式，不过通过它，你有充分的自有度来实现自己需要的视图效果。OverlayContainer 的主要目的在于帮助你完成动画、交互、样式定制等基础工作，使开发者能够将时间和精力仅需投入在视图本身的代码上。</p><p><a href="https://github.com/fatbobman/SwiftUIOverlayContainer" target="_blank">SwiftUIOverlayContainer</a></p><video src="https://cdn.fatbobman.com/swiftui-overlay-demo.mp4" controls = "controls">你的浏览器不支持本视频</video><p>库代码已经修改可以直接在 xcode11 下使用</p><p>代码思路受到了 <a href="https://link.zhihu.com/?target=https%3A//github.com/AndreaMiotto/PartialSheet" target="_blank">PartialSheet</a> 很大的影响，并使用了其部分代码。</p><h2>使用方法</h2><ol><li>Add a <strong>OverlayContainerManager</strong> instance as an <em>environment object</em> <a href=https://www.fatbobman.com/posts/swifui-overlay>...></a></li></ol><br><br><h3><a href=https://www.fatbobman.com/posts/swifui-overlay>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swipeCell</guid><title>用 SwiftUI 实现 iOS mail 程序的侧滑菜单</title><description>随着 SwiftUI2.0 的不断完善，我觉得是时候将我的 app 做一个较大的升级了。之前一直想在 app 中实现类似 iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于 UIKit 的，基本上没有能够很好的适配 SwiftUI 的项目库。最终自己在 Xcode12 实现了一个。</description><link>https://www.fatbobman.com/posts/swipeCell</link><pubDate>Wed, 12 Aug 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>随着 SwiftUI2.0 的不断完善，我觉得是时候将我的 app 做一个较大的升级了。之前一直想在 app 中实现类似 iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于 UIKit 的，基本上没有能够很好的适配 SwiftUI 的项目库。最终自己在 Xcode12 实现了一个。</p></blockquote><p>SwipeCell 是一个用 Swift 5.3 开发的 SwiftUI 库。目标是为了实现类似 iOS Mail 程序实现的左右滑动菜单功能。SwipeCell 需要 XCode 12 ,iOS 14</p><p><a href="https://github.com/fatbobman/SwipeCell" target="_blank">SwipeCell GitHub</a></p><video src="https://cdn.fatbobman.com/SwipeCellDemoVideo.mp4" controls = "controls">你的浏览器不支持本视频</video><h2>配置 Button</h2><pre data-language="swift"><code><span class="hljs-keyword">let</span> button1 = <span class="hljs-type">SwipeCellButton</span>(buttonStyle: .titleAndImage,
                title: <span class="hljs-string">"Mark"</span>, 
                systemImage: <span class="hljs-string">"bookmark"</span>,
                titleColor<a href=https://www.fatbobman.com/posts/swipeCell>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swipeCell>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-import-export</guid><title>HowTo —— SwiftUI2.0 文件导入导出</title><description>SwiftUI2.0 中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</description><link>https://www.fatbobman.com/posts/howto-swiftui-import-export</link><pubDate>Tue, 28 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</p><h2>更新</h2><p>目前 SwiftUI 大幅度的修改了导入导出的用法。</p><p>fileImporter fileExporter fileMover 分别对应 导入、导出、移动</p><p>示例如下：</p><pre data-language="swift"><code>  .fileImporter(isPresented: showImport, allowedContentTypes: [.<span class="hljs-built_in">zip</span>], onCompletion: {
            result <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">switch</span> result{
            <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> url):
                <span class="hljs-built_in">print</span>(store.dataHandler.importData(url))
            <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
                <span class="hljs-built_in">print</span>(error)
      <a href=https://www.fatbobman.com/posts/howto-swiftui-import-export>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-import-export>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader</guid><title>HowTo —— SwiftUI2.0 使用 ScrollViewReader 定位滚动位置</title><description>SwiftUI2.0 增加了滚动定位功能，已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案，并不是通过设置具体的 offset 来进行定位，而是使用 id 来进行位置标记。</description><link>https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader</link><pubDate>Thu, 23 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 增加了滚动定位功能，已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案，并不是通过设置具体的 offset 来进行定位，而是使用 id 来进行位置标记。</p><h2>基本用法——实现从右向左滚动</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScrollReaderTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>(.horizontal) {
            <span class="hljs-comment">//类似 GeometryReader 的使用方式，设定滚动定位区域</span>
            <span class="hljs-type">ScrollViewReader</span>{ proxy <span class="hljs-keyword">in</span>
                <span class="hljs-type">Rectangle</span>()
                    .fill(<span class="hljs-type">LinearGradient</span>(
                      gradient: <span class="hljs-type">Gradient</span>(colors: [.blue,.red]),
                      s<a href=https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-scrollviewReader>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-progressView</guid><title>HowTo —— SwiftUI2.0 使用 ProgressView 显示进度条</title><description>SwiftUI2.0 新增了一些便捷的内置控件，比如说 Label、ProgressView 等。其基本形态都很普通，不过都支持自定义 style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展 style 来完成。</description><link>https://www.fatbobman.com/posts/howto-swiftui-progressView</link><pubDate>Sun, 12 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 新增了一些便捷的内置控件，比如说 Label、ProgressView 等。其基本形态都很普通，不过都支持自定义 style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展 style 来完成。</p><h2>经典小菊花</h2><pre data-language="swift"><code><span class="hljs-type">ProgressView</span>()
</code></pre><h2>线性进度条</h2><pre data-language="swift"><code><span class="hljs-type">ProgressView</span>(<span class="hljs-string">"完成量"</span>, value: <span class="hljs-number">50</span>, total: <span class="hljs-number">100</span>)
</code></pre><img src="https://cdn.fatbobman.com/howto-swiftui-progressView-progress2.png" alt="截屏 2020-07-11 下午 4.09.34"/><h2>代码示例</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProgressTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> timer = <span class="hljs-type">Timer</span>.<span class="hljs-type">TimerPublisher</span>(interval: <span class="hljs-number">0.03</span>, runLoop: .main, mode: .common).autoconnect()
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> value:<span class="hljs-type">Double</span> = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-comment">//无法定义颜色</span>
    <a href=https://www.fatbobman.com/posts/howto-swiftui-progressView>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-progressView>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl</guid><title>HowTo —— 使用 onOpenURL 处理 Universal Links</title><description>SwiftUI2.0 由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织 app, 因此提供了 onOpenURL 来处理 Univeresal Links。不同于在 AppDelegate 或 SceneDelegate 中的解决方案，onOpenURL 作为一个 view modifier，你可以在任意 View 上注册你的 app 的 URL 处理机制。</description><link>https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl</link><pubDate>Sat, 11 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织 app, 因此提供了 onOpenURL 来处理 Univeresal Links。不同于在 AppDelegate 或 SceneDelegate 中的解决方案，onOpenURL 作为一个 view modifier，你可以在任意 View 上注册你的 app 的 URL 处理机制。关于如何为自己的 app 创建 URL Scheme，请参阅 <a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app" target="_blank">苹果的官方文档</a>。</p><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-type">VStack</span>{
   <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello World"</span>)
}
.onOpenURL{ url <span class="hljs-keyword">in</span>
    <span class="hljs-comment">//做点啥</span>
}
</code></pre><h2>示例代码</h2><p>首先在项目中设置 URL</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> tabSelection:<span class="hljs-type">TabSelection</span> = .news
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> show = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body<a href=https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-onOpenUrl>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-toolbar</guid><title>HowTo —— SwiftUI2.0 使用 ToolBar 替代 navigationbarItems</title><description>SwiftUI2.0 为了实现更好的多平台支持同时需要兼顾 1.0 版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如 ToolBar, navigationTitle 等。Toolbar 可以实现 navigationbarItems 的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。</description><link>https://www.fatbobman.com/posts/howto-swiftui-toolbar</link><pubDate>Fri, 10 Jul 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 为了实现更好的多平台支持同时需要兼顾 1.0 版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如 ToolBar, navigationTitle 等。Toolbar 可以实现 navigationbarItems 的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。 &gt; &gt; <strong>在当前的 Xcode Version 12.0 beta 2 (12A6163b) 版本下，ToolBar 在 macOS 下仍然有非常多的问题。</strong></p><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ToolBarTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
      <span class="hljs-type">NavigationView</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"ToolBar 演示"</span>)
            .toolbar{
                <span class="hljs-type">ToolbarItem</span>(placement:.automatic){
                    <span class="hljs-type">H<a href=https://www.fatbobman.com/posts/howto-swiftui-toolbar>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-toolbar>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-link-openurl</guid><title>HowTo —— SwiftUI2.0 使用 Link 或 openURL 打开 URL scheme</title><description>SwiftUI2.0 提供了原生的打开 URL scheme 的功能，我们可以十分方便的在代码中调用其他的 app。</description><link>https://www.fatbobman.com/posts/howto-swiftui-link-openurl</link><pubDate>Fri, 10 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 提供了原生的打开 URL scheme 的功能，我们可以十分方便的在代码中调用其他的 app。</p><h2>Link</h2><p>类似于 NavigationLink , 直接打开 URL scheme 对应的 app</p><pre data-language="swift"><code><span class="hljs-type">Link</span>(<span class="hljs-string">"openURL"</span>,destination:safariUrl)
</code></pre><h2>openURL</h2><p>本次在 SwiftUI2.0 中，苹果提供了若干个通过 Environment 注入的调用系统操作的方法。比如 exportFiles,importFiles,openURL 等。</p><pre data-language="swift"><code>@<span class="hljs-type">Environment</span>(\.openURL) <span class="hljs-keyword">var</span> openURL
openURL.callAsFunction(url)
</code></pre><h2>代码范例</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">URLTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Environment</span>(\.openURL) <span class="hljs-keyword">var</span> openURL
    <span class="hljs-keyword">let</span> safariUrl = <span class="hljs-type">URL</span>(string:<span class="hljs-string">"http://www.apple.com"</span>)!
    <span class="hljs-keyword">let</span> mailUrl = <span class="hljs-type">URL</span>(<a href=https://www.fatbobman.com/posts/howto-swiftui-link-openurl>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-link-openurl>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-grid</guid><title>HowTO —— SwiftUI2.0 原生的 Grid</title><description>SwiftUI 的第一版中，官方并没有提供 UICollectionView 的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0 中，苹果通过 LazyVGrid、LazyHGrid 提供了 Grid 控件。该控件的实现很有 SwiftUI 的风格，和众多的第三方库有显著的区别。</description><link>https://www.fatbobman.com/posts/howto-swiftui-grid</link><pubDate>Fri, 10 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI 的第一版中，官方并没有提供 UICollectionView 的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0 中，苹果通过 LazyVGrid、LazyHGrid 提供了 Grid 控件。该控件的实现很有 SwiftUI 的风格，和众多的第三方库有显著的区别。</p><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GridTest1</span>: <span class="hljs-title">View</span> </span>{
    
    <span class="hljs-keyword">let</span> columns = [
        <span class="hljs-type">GridItem</span>(.adaptive(minimum: <span class="hljs-number">50</span>))
        <span class="hljs-comment">//adaptive 自适应，在一行或一列中放入尽可能多的 Item</span>
        <span class="hljs-comment">//fixed 完全固定的尺寸 GridItem(.fixed(50)), 需显式设置每行或每列中放入的 item 数量</span>
        <span class="hljs-comment">//flexible 用法类似 fixed，不过每个 item 的尺寸可以弹性调整，同样需要显式设置 item 数量</span>
        <span class="hljs-comment">//可以混用</span>
    ]
    <a href=https://www.fatbobman.com/posts/howto-swiftui-grid>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-grid>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-label</guid><title>HowTo —— SwiftUI2.0 如何使用 Label</title><description>SwiftUI2.0 中新增了 Label 控件，方便我们添加由图片和文字组成的标签。</description><link>https://www.fatbobman.com/posts/howto-swiftui-label</link><pubDate>Thu, 9 Jul 2020 13:05:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0 中新增了 Label 控件，方便我们添加由图片和文字组成的标签</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-type">Label</span>(<span class="hljs-string">"Hello World"</span>,systemImage:<span class="hljs-string">"person.badge.plus"</span>)
</code></pre><h2>支持自定义标签风格</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LabelTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>(<span class="hljs-type">LabelItem</span>.labels(),id:\.id){ label <span class="hljs-keyword">in</span>
            <span class="hljs-type">Label</span>(label.title,systemImage:label.image)
                .foregroundColor(.blue)
                .labelStyle(<span class="hljs-type">MyLabelStyle</span>(color:label.color))
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyLabelStyle</span>:<span class="hljs-title">LabelStyle</span></span>{
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Col<a href=https://www.fatbobman.com/posts/howto-swiftui-label>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-label>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-lazyStack</guid><title>HowTo —— SwiftU2.0 LazyVStack LazyHStack</title><description>SwiftUI2.0 提供了 LazyVStack 和 LazyHStack，其作用是只有当 View 在可见区域内才进行渲染，这样可以大大大提高 app 执行效率</description><link>https://www.fatbobman.com/posts/howto-swiftui-lazyStack</link><pubDate>Thu, 9 Jul 2020 13:05:00 +0800</pubDate><content:encoded><![CDATA[<p>SwiftUI2.0 提供了 LazyVStack 和 LazyHStack，其作用是只有当 View 在可见区域内才进行渲染，这样可以大大大提高 app 执行效率。由于 VStack 或 HStack 导致的效率问题，在 <a href="https://zhuanlan.zhihu.com/p/111151515" target="_blank">SwiftUI List (3) —— List、Form、VStack</a> 文章中有简单的比较。</p><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyStack</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">LazyVStack</span>{ <span class="hljs-comment">//换成 VStack 作比较新数据创建的时机</span>
                <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">1000</span>,id:\.<span class="hljs-keyword">self</span>){ id <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Text</span>(<span class="hljs-type">LazyItem</span>(id:id).title)
                }
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyItem</span></span>{
 <a href=https://www.fatbobman.com/posts/howto-swiftui-lazyStack>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-lazyStack>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/howto-swiftui-map</guid><title>HowTo—— Swift2.0 在视图中显示地图</title><description>Swift2.0 中，苹果添加了 Map，让开发者可以非常容易的在 View 中添加需要的地图元素。本文简单介绍了其用法</description><link>https://www.fatbobman.com/posts/howto-swiftui-map</link><pubDate>Thu, 9 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<p>Swift2.0 中，苹果添加了 Map，让开发者可以非常容易的在 View 中添加需要的地图元素。</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> MapKit

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MapView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-comment">//设置初始显示区域</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> region:<span class="hljs-type">MKCoordinateRegion</span> = <span class="hljs-type">MKCoordinateRegion</span>(
        center: <span class="hljs-type">CLLocationCoordinate2D</span>(latitude: <span class="hljs-number">38.92083</span>, longitude: <span class="hljs-number">121.63917</span>),
        span: <span class="hljs-type">MKCoordinateSpan</span>(latitudeDelta: <span class="hljs-number">0.5</span>, longitudeDelta: <span class="hljs-number">0.5</span>)
    )
    
    <span class="hljs-comment">//设置是否持续跟踪用户当前位置</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> trackmode = <span class="hljs-type">MapUserTrackingMode</span>.follow
    
    <span class="hljs-comment">//设置标<a href=https://www.fatbobman.com/posts/howto-swiftui-map>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/howto-swiftui-map>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui2-new-feature-2</guid><title>SwiftUI2.0 —— App、Scene、新的代码结构（二）</title><description>在上篇文章中我们简单了解了 App、Scene，以及几个内置 Scene 的应用。在本文中，我们着重探讨在 SwiftUI2.0 新的代码结构下如果更高效的组织 Data Flow。</description><link>https://www.fatbobman.com/posts/swiftui2-new-feature-2</link><pubDate>Wed, 8 Jul 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<p>在 <a href="https://www.fatbobman.com/posts/swiftui2-new-feature-1/">上篇文章</a> 中我们简单了解了 App、Scene，以及几个内置 Scene 的应用。在本文中，我们着重探讨在 SwiftUI2.0 新的代码结构下如果更高效的组织 Data Flow。</p><h2>新特性</h2><h3>@AppStorage</h3><p>AppStorage 是苹果官方提供的用于操作 UserDefault 的属性包装器。这个功能在 Swift 提供了 propertyWrapper 特性后，已经有众多的开发者编写了类似的代码。功能上没有任何特别之处，不过名称对应了新的 App 协议，让人更容易了解其可适用的周期。</p><ul><li>数据可持久化，app 退出后数据仍保留</li><li>仅包装了 UserDefault，数据可以 UserDefault 正常读取</li><li>可保存的数据类型同 UserDefault，不适合保存复杂类型数据</li><li>在 app 的任意 View 层级都可适用，不过在 app 层使用并不起作用（不报错）</li></ul><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppStorageTest</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-comment">//不报错，不过不起作用</span>
    <span class="hljs-comment">//@AppStorage<a href=https://www.fatbobman.com/posts/swiftui2-new-feature-2>...></a></span></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui2-new-feature-2>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftui2-new-feature-1</guid><title>SwiftUI2.0 —— App、Scene、新的代码结构（一）</title><description>本文简单介绍了 SwiftUI2.0 中全新提供的 App 协议、Scene 协议，浅谈了在全新的代码结构下如何组织 Data Flow，并提供了 SwiftUI2.0 中预置的 Scene 的一些使用示例。当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta 版 (20A4299v)。</description><link>https://www.fatbobman.com/posts/swiftui2-new-feature-1</link><pubDate>Wed, 8 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文简单介绍了 SwiftUI2.0 中全新提供的 App 协议、Scene 协议，浅谈了在全新的代码结构下如何组织 Data Flow，并提供了 SwiftUI2.0 中预置的 Scene 的一些使用示例。 当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta 版 (20A4299v)。</p></blockquote><p>WWDC20 中，苹果为开发者带来了基于 SwiftUI 的全新项目模板。使用该模板，将使项目代码变得异常简洁、清晰。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello world"</span>)
        }
    }
}
</code></pre><p>上述代码可以在屏幕上完成 Hello world 的显示，且能够运行于 iOS 和 macOS 平台下。</p><h2>基本概念</h2><h3>App</h3><p>SwiftUI2.0 提供的全新协议<a href=https://www.fatbobman.com/posts/swiftui2-new-feature-1>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/swiftui2-new-feature-1>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/focusedBinding</guid><title>@FocusedBinding 浅谈</title><description>在苹果 WWDC20 中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding 的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding 在目前 Xcode Version 12.0 beta 2 (12A6163b) 的版本上运行还有很多问题，但我基本上对其有了一定的了解。</description><link>https://www.fatbobman.com/posts/focusedBinding</link><pubDate>Sun, 5 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>在苹果 WWDC20 中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding 的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding 在目前 Xcode Version 12.0 beta 2 (12A6163b) 的版本上运行还有很多问题，但我基本上对其有了一定的了解。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BookCommands</span>: <span class="hljs-title">Commands</span> </span>{
 @<span class="hljs-type">FocusedBinding</span>(\.selectedBook) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selectedBook: <span class="hljs-type">Book?</span>
  <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span> {
    <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Book"</span>) {
        <span class="hljs-type">Section</span> {
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Update Progress..."</span>, action: updateProg<a href=https://www.fatbobman.com/posts/focusedBinding>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/focusedBinding>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftUI2-commands</guid><title>SwiftUI2.0 —— Commands（macOS 菜单）</title><description>本文介绍了 SwiftUI 2.0 中，如何为 macOS 平台添加菜单。苹果在 SwiftUI2.0 中增加了 Multiplatform 项目模板，使得同一套代码，仅需少量的适配便可以同时满足 iOS 以及 macOS 的需要。对于 macOS 上运行的 app, 拥有自定义的菜单是一个十分重要的平台特征。对于没有 macOS 开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</description><link>https://www.fatbobman.com/posts/swiftUI2-commands</link><pubDate>Sat, 27 Jun 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文介绍了 SwiftUI 2.0 中，如何为 macOS 平台添加菜单。 当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta 版 (20A4299v)。</p></blockquote><p>苹果在 SwiftUI2.0 中增加了 Multiplatform 项目模板，使得同一套代码，仅需少量的适配便可以同时满足 iOS 以及 macOS 的需要。对于 macOS 上运行的 app, 拥有自定义的菜单是一个十分重要的平台特征。对于没有 macOS 开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</p><h2>基础</h2><p>在 SwiftUI 下为 app 添加菜单十分方便，下面的代码便可以为 app 添加一个最基础的菜单。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CommandExampleApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
           <span class="hljs-type">ContentView</span>()
        <a href=https://www.fatbobman.com/posts/swiftUI2-commands>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/swiftUI2-commands>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/stateobject</guid><title>SwiftUI 2.0 —— @StateObject 研究</title><description>WWDC20 刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下 SwiftUI 新提供的属性包装器@StateObject。</description><link>https://www.fatbobman.com/posts/stateobject</link><pubDate>Fri, 26 Jun 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>WWDC20 刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下 SwiftUI 新提供的属性包装器@StateObject。</p><h2>为什么要新增@StateObject</h2><p>在我之前的文章 <a href="https://www.fatbobman.com/posts/swiftUI-state/">@State 研究</a> 中我们探讨过@State，通过它，我们可以方便的将值类型数据作为 View 的 Source of truth。在 SwiftUI 1.0 时代，如果想将引用类型作为 source of truth, 通常的方法是使用@EnvironmentObject 或者 @ObservedObject。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RootView</span>:<span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">ContentView</span>()
            .environmentObject(<span class="hljs-type">Store</span>())
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
  <a href=https://www.fatbobman.com/posts/stateobject>...></a></code></pre><br><br><h3><a href=https://www.fatbobman.com/posts/stateobject>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/observableObject-study</guid><title>ObservableObject 研究——想说爱你不容易</title><description>本文主要研究在 SwiftUI 中，采用单一数据源 (Single Source of Truth) 的开发模式，ObservableObject 是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用 ObservableObject 的方式。</description><link>https://www.fatbobman.com/posts/observableObject-study</link><pubDate>Sun, 17 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本文主要研究在 SwiftUI 中，采用单一数据源 (Single Source of Truth) 的开发模式，ObservableObject 是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用 ObservableObject 的方式。</p><h2>单一数据源</h2><p>我是在去年阅读王巍写的 <a href="https://objccn.io/products/swift-ui" target="_blank">《SwiftUI 与 Combine 编程》</a> 才第一次接触到<strong>单一数据源</strong>这一概念的。</p><ul><li>将 app 当作一个状态机，状态决定用户界面。</li></ul><ul><li>这些状态都保存在一个 Store 对象中，被称为 State。</li></ul><ul><li>View 不能直接操作 State，而只能通过发送 Action 的方式，间接改变存储在 Store 中的 State。</li></ul><ul><li>Reducer 接受原有的 State 和发送过来的 Action，生成新的 State。</li></ul><ul><li>用新的 State 替换 Store 中原有的状态，并用新状态来驱动更新界面。</li></ul><p>在该书中结合作者之前 Redux、RxSwift 等开发经验，提供了<a href=https://www.fatbobman.com/posts/observableObject-study>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/observableObject-study>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/swiftUI-state</guid><title>@state 研究</title><description>本文试图探讨并分析 SwiftUI 中 @State 的实现方式和运行特征；最后提供了一个有关扩展@State 功能的思路及例程。读者需要对 SwiftUI 的响应式编程有基本概念。</description><link>https://www.fatbobman.com/posts/swiftUI-state</link><pubDate>Sun, 17 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文试图探讨并分析 SwiftUI 中 @State 的实现方式和运行特征；最后提供了一个有关扩展@State 功能的思路及例程。读者需要对 SwiftUI 的响应式编程有基本概念。</p></blockquote><h2>研究的意义何在</h2><p>我在去年底使用了 SwiftUI 写了第一个 iOS app <strong>健康笔记</strong>，这是我第一次接触响应式编程概念。在有了些基本的认识和尝试后，深深的被这种编程的思路所打动。不过，我在使用中也发现了一些奇怪的问题。就像之前在 <a href="https://zhuanlan.zhihu.com/p/103822455" target="_blank">老人新兵</a> 中说的那样，我发现在视图（View）数量达到一定程度，随着数据量的增加，整个 app 的响应有些开始迟钝，变得有粘滞感、不跟手。app 响应出现了问题一方面肯定和我的代码效率、数据结构设计欠佳有关；不过随着继续分析，发现其中也有很大部分原因来自于 SwiftUI 中所使用的响应式的实现方式。不恰当的使用，可能导致响应速度会随着数据量及 View 量的增加而大幅下降。通过一段时间的研究和分析，我打算用两篇文章来阐述这方面的问题，并尝试提供一个现阶段的使用思路。</p><h2>数据（状态）驱动</h2><p>在<a href=https://www.fatbobman.com/posts/swiftUI-state>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/swiftUI-state>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/vapor4</guid><title>Vapor4 的安装与配置</title><description>本文介绍了如何在 mac 10.5.4 和 ubuntu 18.04 下安装 Vapor 命令行工具，创建 Vapor 项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为：Vapor4,Swift5.2,Catalina 10.5.4,Ubuntu18.04</description><link>https://www.fatbobman.com/posts/vapor4</link><pubDate>Thu, 7 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文介绍了如何在 mac 10.5.4 和 ubuntu 18.04 下安装 Vapor 命令行工具，创建 Vapor 项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为：Vapor4,Swift5.2,Catalina 10.5.4,Ubuntu18.04</p></blockquote><p>最近新开通了一个云服务器（Linux 系统），使用 <a href="https://hexo.io/zh-cn/index.html/" target="_blank">Hexo</a> 创建了新的博客网页。考虑增加点简单的交互功能，所以需要在服务器端添加逻辑处理能力。由于近半年来基本上都是在使用 Swift，所以打算尝试一下 Server Side Swift。没有太仔细选择各种框架，看过几个介绍 Vapor 使用的视频后，感觉不错，便开始尝试安装配置。</p><p>Vapor 的官方文档实在是有很大的问题，网上的不少心得、教程又有点陈旧（目前版本调整较大）。通过两天的折腾，终于基本上理出了脉络，初步搭建了开发和生产环境。</p><h2>什么是 Vapor</h2><p><a href="https://github.com/vapor/vapor" target="_blank">Vapor</a> 是一个使用 swift 语言编写的 Web 网络框架，它是跨平台的（mac、Linux），用户可以使用 <a href=https://www.fatbobman.com/posts/vapor4>...></a></p><br><br><h3><a href=https://www.fatbobman.com/posts/vapor4>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://www.fatbobman.com/posts/first-post</guid><title>时隔多年，重新创建了博客</title><description>用 Hexo 创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。</description><link>https://www.fatbobman.com/posts/first-post</link><pubDate>Thu, 30 Apr 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>用 Hexo 创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。</p><br><br><h3><a href=https://www.fatbobman.com/posts/first-post>查看全文</a></h3>]]></content:encoded></item></channel></rss>